using Avalonia;
using Avalonia.Animation;
using Avalonia.Controls;
using Avalonia.Controls.ApplicationLifetimes;
using Avalonia.Media;
using Avalonia.Styling;
using Avalonia.Threading;
using Avalonia.VisualTree;
using DPUruNet;
using ExCSS;
using Microsoft.AspNetCore.SignalR.Client;
using Microsoft.Extensions.DependencyInjection;
using MsBox.Avalonia.Enums;
using NAudio.Wave;
using Newtonsoft.Json;
using NLog;
using NLog.Config;
using NLog.Targets;
using ReactiveUI;
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Data;
using System.Linq;
using System.Net.NetworkInformation;
using System.Reactive;
using System.Reactive.Linq;
using System.Runtime.InteropServices;
using System.Threading;
using System.Threading.Tasks;
using System.Windows.Input;
using VTA_Clock;
using VTACheckClock.DBAccess;
using VTACheckClock.Helpers;
using VTACheckClock.Models;
using VTACheckClock.Services;
using VTACheckClock.Services.Libs;
using VTACheckClock.Views;
using static VTACheckClock.Services.CommonObjs;
using static VTACheckClock.Views.MessageBox;
using Bitmap = Avalonia.Media.Imaging.Bitmap;
using Cue = Avalonia.Animation.Cue;

namespace VTACheckClock.ViewModels
{
    /*public*/
    class MainWindowViewModel : ViewModelBase
    {
        public static string Greeting => "Welcome to Avalonia!"; //Code generated by default

        private WSClient? _WSClient;
        private SignalRClient? _signalRClient;
        private string _connectionStatus = "Servidor WebSocket desactivado";
        public string _currentTime = "00:00:00";
        public RemoteTime? _currentRemoteTime;
        public string _currentLongDate = "";
        public string _networkConStatus = "Sin conexión";
        public string _office = "";
        public string _empName = "";
        public string _empEvent = "Esperando huella...";
        private string? _searchText;
        private string _noticeTitle = "", _noticeBody = "", _platform = "", _syncError = "";
        private bool _IsWebSocketConnected, _IsNetConnected;
        private int _selectedIndex = 0, _selectedItem = 0, _lastEmployeeEvent = 0;
        private int _foundIndex = -2, _pwdPunchIndex = -2; //-2 Initialized, -1 Not found Index
        private bool _isSyncing = true, _sync = false;
        private Notice? _newNotice;
        private Bitmap? _logoImage;
        private Bitmap? _noticeImage;
        private bool _emptyNotices;
        private DispatcherTimer tmrCachedTime = new();
        private readonly DispatcherTimer tmrClock = new();
        private readonly DispatcherTimer tmrNotices = new();
        private readonly DispatcherTimer tmrSyncRetry = new();
        private readonly DispatcherTimer tmrCheckNetConnection = new();
        private readonly BackgroundWorker bgwLoader = new();
        private DateTime CacheCalculatedTime; // Hora basada en NTP;
        private DateTime lastUpdateTime;
        private DateTime lastNetworkTime;
        private TimeSpan networkOffset;
        private int failedAttempts = 0; // Contador de intentos fallidos

        //private SourceList<Employee> _sourceList = new();
        //private readonly ReadOnlyObservableCollection<Employee> _attsList;
        //public ReadOnlyObservableCollection<Employee> AttsList => _attsList;
        public ObservableCollection<Employee>? AttsList { get; set; } = [];
        public ObservableCollection<Employee> SearchResults { get; } = [];
        public ObservableCollection<EmployeePunch> EmpPunches { get; }
        public ObservableCollection<Notice> Notices { get; }
        public ObservableCollection<FMDItem> FingerPrints { get; }
        public List<PageTransition> PageTransitions { get; } = [];
        public ReactiveCommand<Unit, Unit>? PwdPunchCommand { get; }
        public Interaction<PwdPunchViewModel, int> ShowPwdPunchDialog { get; } = new();
        public Interaction<WebsocketLoggerViewModel, bool> ShowLoggerDialog { get; } = new();
        public Interaction<AttendanceViewModel, bool> ShowAttendanceRptDialog { get; } = new();
        public Interaction<LoginViewModel, bool> ShowLoginDialog { get; } = new();
        public ICommand? LoginCommand { get; }
        public ICommand? LogOutCommand { get; }
        public ICommand? PreviewLoggerCommand { get; }
        public ICommand? PreviewAttendanceReportCommand { get; }
        public ICommand? SyncEvtCommand { get; }

        public ICommand? TestCommand { get; }

        public ICommand SendEmailCommand { get; }

        //public CheckClockMainViewModel? ClockMain { get; } DEPRECATED AND DELETED FILE: USED ONLY WITH "Content"

        ViewModelBase content = new();

        public Bitmap? LogoImage { 
            get => _logoImage;
            set => this.RaiseAndSetIfChanged(ref _logoImage, value);
        }
        
        //public Task<Bitmap?> LogoImageFromWebSite { get; } = ImageHelper.LoadFromWeb(new Uri("https://upload.wikimedia.org/wikipedia/commons/4/41/NewtonsPrincipia.jpg"));
        
        public string CurrentTime
        {
            get => _currentTime;
            set => this.RaiseAndSetIfChanged(ref _currentTime, value);
        }

        /// <summary>
        /// Esta variable es un modelo que almacena la hora remota en formato DateTime y String.
        /// </summary>
        public RemoteTime? CurrentRemoteTime
        {
            get => _currentRemoteTime;
            set => this.RaiseAndSetIfChanged(ref _currentRemoteTime, value);
        }

        public string CurrentLongDate
        {
            get => _currentLongDate;
            set => this.RaiseAndSetIfChanged(ref _currentLongDate, value);
        }

        public string ConnectionStatus
        {
            get => _connectionStatus;
            set => this.RaiseAndSetIfChanged(ref _connectionStatus, value);
        }

        public bool IsWebSocketConnected
        {
            get => _IsWebSocketConnected;
            set => this.RaiseAndSetIfChanged(ref _IsWebSocketConnected, value);
        }

        public string NetworkConStatus
        {
            get => _networkConStatus;
            set => this.RaiseAndSetIfChanged(ref _networkConStatus, value);
        }

        public string Office
        {
            get => _office;
            set => this.RaiseAndSetIfChanged(ref _office, value);
        }

        public bool IsNetConnected
        {
            get => _IsNetConnected;
            set => this.RaiseAndSetIfChanged(ref _IsNetConnected, value);
        }

        public string EmployeeName
        {
            get => _empName;
            set => this.RaiseAndSetIfChanged(ref _empName, value);
        }

        public string EmployeeEvent
        {
            get => _empEvent;
            set => this.RaiseAndSetIfChanged(ref _empEvent, value);
        }

        public int SelectedIndex
        {
            get => _selectedIndex;
            set => this.RaiseAndSetIfChanged(ref _selectedIndex, value);
        }

        public int SelectedItem
        {
            get => _selectedItem;
            set => this.RaiseAndSetIfChanged(ref _selectedItem, value);
        }

        public int LastEmployeeEventItem
        {
            get => _lastEmployeeEvent;
            set => this.RaiseAndSetIfChanged(ref _lastEmployeeEvent, value);
        }

        public bool NoticeCollectionEmpty
        {
            get => _emptyNotices;
            set => this.RaiseAndSetIfChanged(ref _emptyNotices, value);
        }

        public string NoticeTitle
        {
            get => _noticeTitle;
            set => this.RaiseAndSetIfChanged(ref _noticeTitle, value);
        }

        public string NoticeBody
        {
            get => _noticeBody;
            set => this.RaiseAndSetIfChanged(ref _noticeBody, value);
        }

        public Bitmap? NoticeImage
        {
            get => _noticeImage;
            private set => this.RaiseAndSetIfChanged(ref _noticeImage, value);
        }

        public string? SearchText
        {
            get => _searchText;
            set => this.RaiseAndSetIfChanged(ref _searchText, value);
        }

        private PageTransition? _SelectedTransition;

        /// <summary>
        /// Gets or sets the transition to play
        /// </summary>
        public PageTransition? SelectedTransition
        {
            get => _SelectedTransition;
            set { this.RaiseAndSetIfChanged(ref _SelectedTransition, value); }
        }

        private int _Duration = 500;

        /// <summary>
        /// Gets or Sets the duration
        /// </summary>
        public int Duration
        {
            get => _Duration;
            set {
                this.RaiseAndSetIfChanged(ref _Duration, value);
                SetupTransitions();
            }
        }

        public int FoundIndex
        {
            get => _foundIndex;
            set => this.RaiseAndSetIfChanged(ref _foundIndex, value);
        }

        public int PwdPunchIndex
        {
            get => _pwdPunchIndex;
            set => this.RaiseAndSetIfChanged(ref _pwdPunchIndex, value);
        }

        public bool IsSyncing
        {
            get => _isSyncing;
            set => this.RaiseAndSetIfChanged(ref _isSyncing, value);
        }

        public bool ShowLoader
        {
            get => _sync;
            set => this.RaiseAndSetIfChanged(ref _sync, value);
        }

        public Notice? NewNotice
        {
            get => _newNotice;
            set => this.RaiseAndSetIfChanged(ref _newNotice, value);
        }

        public string PlatformInfo {
            get => _platform;
            set => this.RaiseAndSetIfChanged(ref _platform, value);
        }

        public string SyncError
        {
            get => _syncError;
            set => this.RaiseAndSetIfChanged(ref _syncError, value);
        }

        private readonly EmailSenderHandler EmailSender = new();

        public MainWindowViewModel(string? text = null)
        {
            //Content = ClockMain = new CheckClockMainViewModel(FoundIndex);
            AttsList = [];
            EmpPunches = [];
            Notices = [];
            FingerPrints = [];

            AttsList.CollectionChanged += AttsList_CollectionChanged;
            AddNLogConfiguration();
            Dispatcher.UIThread.InvokeAsync(async() => {
                await FormLoad();
                await FormShown();
            });

            this.WhenAnyValue(x => x.Notices.Count).Subscribe(x => NoticeCollectionEmpty = x == 0);

            //_sourceList.Connect()
            //.Sort(SortExpressionComparer<Employee>.Ascending(t => t.Index))
            //.Bind(out _attsList)
            //.Subscribe();

            this.WhenAnyValue(x => x.PwdPunchIndex).Where(y => y != -2).Subscribe(PunchIt!);
            //this.WhenAnyValue(x => x.SelectedIndex).Subscribe(ShowEventsByEmployee!);

            LoginCommand = ReactiveCommand.CreateFromTask(InvokeLogin);
            LogOutCommand = ReactiveCommand.CreateFromTask(async() => {
                Messenger.Send("TogglePanel", true);

                var _result = await ShowPrompt("¿Salir?", "¿Confirma que desea salir de la aplicación?");
                if (_result == ButtonResult.Yes) {
                    GlobalVars.ForceExit = true;

                    await InvokeManualSync();
                    await new MainWindow().LogOut(true);
                }

                Messenger.Send("TogglePanel", false);
            });

            PreviewLoggerCommand = ReactiveCommand.CreateFromTask(async () => {
                var frmPassPunc = new WebsocketLoggerViewModel();
                await ShowLoggerDialog.Handle(frmPassPunc);
            });

            PreviewAttendanceReportCommand = ReactiveCommand.CreateFromTask(async () => {
                var vmAtteRptViewModel = new AttendanceViewModel();
                await ShowAttendanceRptDialog.Handle(vmAtteRptViewModel);
            });

            //SyncEvtCommand = ReactiveCommand.CreateFromTask(InvokeManualSync(false));
            this.WhenAnyValue(x => x.ShowLoader).Where(y => y).Subscribe(InvokeManualSyncEvt!);
            this.WhenAnyValue(x => x.NewNotice).Where(y => y != null).Subscribe(AddNewNotice!);
            this.WhenAnyValue(x => x.SearchText).Throttle(TimeSpan.FromMilliseconds(500)).ObserveOn(RxApp.MainThreadScheduler).Subscribe(DoSearch!);

            NetworkChange.NetworkAvailabilityChanged += OnNetworkAvailabilityChanged;

            SendEmailCommand = ReactiveCommand.CreateFromTask(async () => await SendEmployeesWithNoCheckInOut());
        }

        private void AttsList_CollectionChanged(object? sender, NotifyCollectionChangedEventArgs e)
        {
            try {
                if(e.Action == NotifyCollectionChangedAction.Add) {
                    foreach (Employee newItem in e.NewItems)
                    {
                        SearchResults.Add(newItem);
                    }
                }
                else if (e.Action == NotifyCollectionChangedAction.Reset) {
                    SearchResults.Clear();
                }
            }
            catch (Exception ex) {
                log.Warn("Error al actualizar la búsqueda: " + ex.ToString());
            }
        }

        /// <summary>
        /// Registra un manejador de eventos para el evento de registro de NLog
        /// </summary>
        private static void AddNLogConfiguration()
        {
            // Registrar un manejador de eventos para el evento de registro de NLog
            var config = new LoggingConfiguration();
            //var memoryTarget = new MemoryTarget("logViewer");
            //config.AddTarget(memoryTarget);
            //config.AddTarget(fileTarget);
            //config.LoggingRules.Add(new LoggingRule("app_logger", LogLevel.Debug, memoryTarget));

            // Configurar la salida del Logger
            var fileTarget = new FileTarget("logfile")
            {
                FileName = "${basedir}/logs/AppLog.txt",
                //Layout = "${longdate} ${level:uppercase=true} ${message} ${exception:format=ToString}${newline}",
                ArchiveAboveSize = 10240,
                AutoFlush = true,
                KeepFileOpen = false, //(false) Permite que el archivo se cierre después de cada escritura
                ArchiveFileName = "${basedir}/logs/archive/AppLog.{####}.txt",
                ArchiveEvery = FileArchivePeriod.Day,
                ArchiveNumbering = ArchiveNumberingMode.DateAndSequence, //Sequence
                MaxArchiveFiles = 20,
                Encoding = System.Text.Encoding.UTF8
            };

            config.AddRule(LogLevel.Trace, LogLevel.Fatal, fileTarget);
            config.AddRule(new LoggingRule("app_logger", LogLevel.Info, fileTarget));
            
            // Asignar la configuración al LogManager
            LogManager.Configuration = config;
            //LogManager.ReconfigExistingLoggers();
        }

        public ViewModelBase Content
        {
            get => content;
            private set => this.RaiseAndSetIfChanged(ref content, value);
        }

        /// <summary>
        /// Detectar la plataforma y configurar la detección de cambios en la hora del sistema
        /// </summary>
        private static void GetPlatform()
        {
            /*
            var runtimeInfo = AvaloniaLocator.Current.GetService<IRuntimePlatform>()?.GetRuntimeInfo();
            if (runtimeInfo is { } info) {
                if (RuntimeInformation.IsOSPlatform(OSPlatform.Create("BROWSER"))) {
                    if (info.IsDesktop) {
                      PlatformInfo = "Platform: Desktop (browser)";
                    } else if (info.IsMobile) {
                      PlatformInfo = "Platform: Mobile (browser)";
                    } else {
                      PlatformInfo = "Platform: Unknown (browser) - please report";
                    }
                } else {
                    if (info.IsDesktop) {
                        PlatformInfo = "Platform: Desktop (native)";
                    } else if (info.IsMobile) {
                        PlatformInfo = "Platform: Mobile (native)";
                    } else {
                        PlatformInfo = "Platform: Unknown (native) - please report";
                    }
                }
            }
            */

            if (RuntimeInformation.IsOSPlatform(OSPlatform.Linux))
            {
                // Configurar la detección de cambios en la hora del sistema en Linux (utilizando libnotify, por ejemplo)
            }
            else if (RuntimeInformation.IsOSPlatform(OSPlatform.OSX))
            {
                // Configurar la detección de cambios en la hora del sistema en macOS
            }
        }

        private void SetupTransitions()
        {
            if (PageTransitions.Count == 0)
            {
                PageTransitions.AddRange([
                    new PageTransition("None"),
                    new PageTransition("CrossFade"),
                    new PageTransition("Slide horizontally"),
                    new PageTransition("Slide vertically"),
                    new PageTransition("Composite"),
                    new PageTransition("Custom")
                ]);
            }

            //The "CrossFade" fades out the current view and fades in the new view by animating the opacity.
            PageTransitions[1].Transition = new CrossFade(TimeSpan.FromMilliseconds(Duration));
            // The "PageSlide" slides the content either horizontally or vertically.
            // You can specify the slide axis via the Orientation-property. The default value is Horizontal.
            PageTransitions[2].Transition = new PageSlide(TimeSpan.FromMilliseconds(Duration), PageSlide.SlideAxis.Horizontal);
            PageTransitions[3].Transition = new PageSlide(TimeSpan.FromMilliseconds(Duration), PageSlide.SlideAxis.Vertical);
            //The "CompositePageTransition" is used create a combined transition of several different transitions.
            var compositeTransition = new CompositePageTransition();
            compositeTransition.PageTransitions.Add(PageTransitions[1].Transition!);
            compositeTransition.PageTransitions.Add(PageTransitions[2].Transition!);
            compositeTransition.PageTransitions.Add(PageTransitions[3].Transition!);
            PageTransitions[4].Transition = compositeTransition;

            PageTransitions[5].Transition = new CustomTransition(TimeSpan.FromMilliseconds(Duration));

            _SelectedTransition = PageTransitions[1];
        }

        private bool IsInternetConnected;
        private void OnNetworkAvailabilityChanged(object? sender, NetworkAvailabilityEventArgs e)
        {
            try {
                // Actualizar el estado de conexión a internet
                IsInternetConnected = e.IsAvailable;

                Dispatcher.UIThread.InvokeAsync(async () => {
                    await ToggleConnIndicator();

                    if (IsInternetConnected) {
                        // Esperar durante 5 segundos antes de sincronizar datos
                        await Task.Delay(TimeSpan.FromSeconds(5));

                        // Verificar si la conexión sigue activa antes de sincronizar
                        if (IsInternetConnected) {
                            log.Warn("El equipo se conectó de nuevo a Internet.");

                            await UpdateNetworkTimeAsync();
                            await SyncWithLoader();
                            await ReloadWebSocket();
                        } else {
                            log.Warn("La conexión a Internet se perdió nuevamente antes de sincronizar.");
                        }
                    } else { 
                        log.Warn("El equipo se desconectó de Internet.");
                    }
                });
            } catch(Exception ex) {
                IsInternetConnected = false;
                log.Warn("OnNetworkAvailabilityChangedError: " + ex.Message);
            }
        }

        private bool IsDuplicated(Employee? item) => AttsList != null && AttsList.Any(e => e.EventTime == item.EventTime && e.EventType == item.EventType && e.EmpID == item.EmpID);

        #region WebSocket Configuration
        private async void InitializeWebSocket()
        {
            try
            {
                if(m_settings.UsePusher) {
                    await _WSClient.Connect();
                }
                else {
                    await _signalRClient.InitializeAsync();
                }

                ConnectionStatus = "Servidor WebSocket activado";
            }
            catch (Exception ex) {
                log.Error(ex, "Error al inicializar el Servidor WebSocket");
                ConnectionStatus = "Error de conexión";
            }
        }

        /// <summary>
        /// Configura los eventos del cliente WebSocket.
        /// </summary>
        private void ConfigureWebSocketEvents()
        {
            if (m_settings.UsePusher)
            {
                _WSClient = new WSClient();
                _WSClient.PunchReceived += WSClient_MessageReceived;
            }
            else {
                _signalRClient = App.ServiceProvider.GetRequiredService<SignalRClient>();
                _signalRClient.ConnectionStateChanged += OnHubConnectionStateChanged;
                _signalRClient.MessageReceived += SignalRClient_MessageReceived;
            }
        }

        private async Task ReloadWebSocket()
        {
            try
            {
                if (m_settings.UsePusher)
                {
                    await _WSClient.ReloadConnection();
                }
                else
                {
                    await _signalRClient.ReloadConnectionAsync();
                }
            }
            catch (Exception ex)
            {
                log.Error(ex, "Error al reconectar el Servidor WebSocket");
            }
        }

        private void OnHubConnectionStateChanged(object? sender, HubConnectionState state)
        {
            ConnectionStatus = state switch {
                HubConnectionState.Connecting => "Conectando al servidor WebSocket...",
                HubConnectionState.Connected => "Servidor WebSocket en línea",
                HubConnectionState.Disconnected => "Servidor WebSocket desconectado",
                HubConnectionState.Reconnecting => "Reconectando Websocket...",
                _ => "Estado desconocido"
            };
        }

        /// <summary>
        /// Recibe el mensaje enviado desde el servidor de SignalR al cliente.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="message"></param>
        private void SignalRClient_MessageReceived(object? sender, string message)
        {
            try {
                ValidateReceivedPunch(message);
            }
            catch (Exception ex)
            {
                log.Error(ex, "Error al procesar el mensaje recibido");
            }
        }

        /// <summary>
        /// Escucha los cambios del evento 'PunchReceived' y recibe la información enviada desde el servidor al cliente. 
        /// Finalmente, actualiza el listado de asistencias en todos los clientes subscritos al canal y agrega el registro en cache y memoria de la Aplicación.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="message"></param>
        private void WSClient_MessageReceived(object? sender, string message)
        {
            try
            {
                ValidateReceivedPunch(message);
            }
            catch (Exception ex)
            {
                log.Warn("Error al procesar el Evento de Websocket recibido: " + ex.Message);
            }
        }
        #endregion

        public static int GetIndexByName(string[] array, string? name)
        {
            var index = Array.IndexOf(array, name);
            return (index != -1) ? index : 0;
        }

        /// <summary>
        /// Valida si el registro de asistencia ya existe en la lista de asistencias. Si no existe, lo agrega a la lista y lo almacena en caché.
        /// </summary>
        /// <param name="message"></param>
        public async void ValidateReceivedPunch(string message)
        {
            Employee? EmpData = Employee.FromJson(message);

            // Verifica si estos en el hilo de la UI
            if (Dispatcher.UIThread.CheckAccess())
            {
                // Si ya estás en el hilo de la UI, simplemente agrega el elemento
                if (!IsDuplicated(EmpData))
                {
                    AttsList.Add(EmpData!);
                    await AddEmployee(message);
                }
            }
            else
            {
                // Si no estás en el hilo de la UI, usa Dispatcher para invocar la operación en el hilo de la UI
                if (!IsDuplicated(EmpData))
                {
                    await Dispatcher.UIThread.InvokeAsync(() => AttsList.Add(EmpData!));
                    await AddEmployee(message);
                }
            }

            SelectedIndex = AttsList.Count - 1;
        }

        /// <summary>
        /// Agrega un registro de Evento recibido por medio de un Canal de Websocket, en memoria y cache para sincronizar diferentes dispositivos conectados a un canal de WebSocket.
        /// </summary>
        /// <param name="PunchRecord"></param>
        /// <returns></returns>
        public async Task<bool> AddEmployee(string message)
        {
            PunchRecord? PunchRecord = JsonConvert.DeserializeObject<PunchRecord>(message);

            PunchLine new_punch = new() {
                Punchemp = PunchRecord.IdEmployee,
                Punchevent = PunchRecord.IdEvent,
                Punchtime = PunchRecord?.EventTime != null ? DateTime.Parse(PunchRecord.EventTime) : DateTime.MinValue,
                Punchinternaltime = PunchRecord?.InternalEventTime != null ? DateTime.Parse(PunchRecord.InternalEventTime) : DateTime.MinValue
            };

            // Agrega el registro en la lista de la "memoria"
            emp_punches.Rows.Add(new_punch.Punchemp.ToString(), new_punch.Punchevent.ToString(), PunchRecord.EventTime, PunchRecord.InternalEventTime);

            // Agrega el registro en el archivo de Cache
            GlobalVars.AppCache.StorePunch(new_punch);

            return await Task.FromResult(true);
        }

        /// <summary>
        /// Muestra una ventana emergente, el cual pregunta si quiere cerrar sesión, únicamente cuando se presiona el botón de "Salir".
        /// </summary>
        /// <returns></returns>
        private async Task InvokeLogin()
        {
             if (GlobalVars.BeOffline) {
                 await ShowMessage("Aplicación sin conexión", "La aplicación se encuentra actualmente en modo 'Fuera de línea'. No es posible reconfigurarla hasta que exista una conexión activa a Internet.", -1, 140);
             } else {
                var frmPassPunc = new LoginViewModel();
                await ShowLoginDialog.Handle(frmPassPunc);
             }
        }

        /// <summary>
        /// Método para buscar un empleado en la lista de checadas en la pantalla principal
        /// </summary>
        /// <param name="s">Nombre del empleado</param>
        private async void DoSearch(string s)
        {
            SearchResults.Clear();

            if (!string.IsNullOrWhiteSpace(s) && AttsList != null)
            {
                var filteredEntries = await Task.Run(() => {
                    return AttsList.Where(entry => entry.FullName.ToLower().Contains(s.ToLower(), StringComparison.OrdinalIgnoreCase)).ToList();
                });

                foreach (var entry in filteredEntries)
                {
                    SearchResults.Add(entry);
                }
            } else if(AttsList != null) {
                foreach (var entry in AttsList)
                {
                    SearchResults.Add(entry);
                }
            }

            SelectedIndex = SearchResults.Count - 1;
        }

        #region Inicialización
        private int IDThreshold = 0; //CommonProcs.ParamInt(7) * 1 / CommonProcs.ParamInt(8)
        private static int curr_not = 0;
        private bool forceexit = false;
        private DataTable? emp_punches;
        private readonly NoticeData def_not = new() { nottit = "", notmsg = "No se encontró ningún aviso para esta ubicación o no se pudieron cargar." };
        private List<Fmd>? las_fmds;
        private static List<NoticeData>? notices;
        private List<FMDItem>? fmd_collection;
        public int elid_idx = -1;
        public MainSettings? m_settings;
        public ClockSettings? c_settings;
        private static readonly Logger log = LogManager.GetLogger("app_logger");
        private static readonly string[] PunchSounds = { "", "Entry", "Exit", "Unknown", "Error" };
        private static WaveOutEvent? waveOutEvent;
        private bool ScheduleTriggered = false;
        private static DateTime LastSyncDate = DateTime.MinValue;
        private static bool RetryingSync = false;

        /// <summary>
        /// Evento LOAD del formulario.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private async Task FormLoad()
        {
            m_settings = RegAccess.GetMainSettings() ?? new MainSettings();
            c_settings = RegAccess.GetClockSettings() ?? new ClockSettings();

            await FormInit();
        }

        /// <summary>
        /// Inicializa el entorno del formulario.
        /// </summary>
        private async Task FormInit()
        {
            ConfigureWebSocketEvents();
            InitializeWebSocket();
            
            GetPlatform();
            SetupTransitions();
            ConfigTimers();
            ToggleTimers(false);

            await SetClock();
            await UpdateInfoLabels(0);
            MakeClockSession();
            GetOffice();
            SetLogo();
            StartReader();
        }

        /// <summary>
        /// Invoca la sincronización de inicio.
        /// </summary>
        private async Task StarterSync()
        {
            GlobalVars.StartingUp = true;
            Messenger.Send("ToggleOverlay", true);
            await SyncWithLoader();
            Messenger.Send("ToggleOverlay", false);
            GlobalVars.StartingUp = false;
        }

        /// <summary>
        /// Crea el objeto SessionData que utilizará la interfaz del Reloj Checador.
        /// </summary>
        private static void MakeClockSession()
        {
            GlobalVars.clockSession = new SessionData {
                usrname = GlobalVars.clockSettings?.clock_user,
                passwd = GlobalVars.clockSettings?.clock_pass,
                accpriv = GlobalVars.ClockStartPriv
            };
        }

        /// <summary>
        /// Ejecuta todos los procesos de sincronización y actualización del formulario.
        /// </summary>
        private async Task<bool> SyncAll()
        {
            CommonProcs.SetOfflineMode();
            await ToggleConnIndicator();

            bool upload_result;
            //ToggleConnIndicator(!GlobalVars.BeOffline);

            try {
                await TakeMyTime();
                upload_result = await UploadPunches();
                await GetNotices();
                upload_result = await GetFMDs();
                await ConsolidateHistory();
                await UpdateHistoryPanel();

                if (upload_result && !GlobalVars.BeOffline) RegAccess.SaveLastSync(GetRemoteDateTime());
            } catch(Exception ex) {
                SyncError = "Ocurrió un error no especificado durante la sincronización. Favor de contactar al administrador del sistema. " + ex.Message;
                HideLoader();
                upload_result = false;
            }

            if (ScheduleTriggered && upload_result) {
                LastSyncDate = GetRemoteDateTime();
                ScheduleTriggered = false;
                log.Info("La sincronización programada ha finalizado correctamente!");
            } else if(RetryingSync && upload_result) {
                log.Info("El intento de Sincronización finalizó correctamente!");
                RetryingSync = false;
            }

            return upload_result;
        }

        private DateTime GetRemoteDateTime() => CurrentRemoteTime.CurrentTime;

        /// <summary>
        /// Registra la marca de tiempo actual del cliente en el servidor.
        /// </summary>
        private async Task TakeMyTime()
        {
            try {
                ScantRequest scantreq = new() {
                    Question = (
                        GlobalVars.clockSettings?.clock_uuid ?? Guid.Empty.ToString() + "|" +
                        GlobalVars.clockSettings?.clock_office.ToString() + "|" +
                        GetRemoteDateTime().ToString("yyyy/MM/ddTHH:mm:ss")
                    )
                };

                await CommonProcs.SyncWatchesAsync(scantreq);
            } catch {
                return;
            }
        }

        /// <summary>
        /// Recupera las huellas dactilares de los empleados asignados a la oficina actual.
        /// </summary>
        private async Task<bool> GetFMDs()
        {
            DataTable emp_dt;

            int el_idx = 0;
            las_fmds = null;
            fmd_collection = null;
            las_fmds = [];
            fmd_collection = [];

            if (!GlobalVars.BeOffline)
            {
                emp_dt = await CommonProcs.GetOfficeFMDsAsync(new ScantRequest { Question = GlobalVars.clockSettings?.clock_office.ToString() });

                if (emp_dt == null)
                {
                    emp_dt = VoidFMDs;
                } else {
                    await GlobalVars.AppCache.SaveEmployeesAsync(emp_dt);
                }
            } else {
                emp_dt = GlobalVars.AppCache.RetrieveEmployees();
            }

            foreach (DataRow dr in emp_dt.Rows)
            {
                las_fmds.Add(new Fmd(SimpleAES.ToHexBytes(dr["FingerFMD"].ToString()!), GlobalVars.FMDFormat, GlobalVars.FMDVersion));

                var item = new FMDItem {
                    idx = el_idx,
                    offid = int.Parse(dr["OffID"].ToString() ?? "0"),
                    empid = int.Parse(dr["EmpID"].ToString() ?? "0"),
                    fingid = int.Parse(dr["FingerID"].ToString() ?? "0"),
                    empnum = dr["EmpNum"].ToString(),
                    empnom = dr["EmpName"].ToString(),
                    emppass = dr["EmpPass"].ToString(),
                    fmd = SimpleAES.ToHexBytes(dr["FingerFMD"].ToString()!)
                };

                fmd_collection.Add(item);
                FingerPrints.Add(item);

                el_idx++;
            }

            if (las_fmds.Count <= 0) las_fmds.Add(new Fmd(new byte[124], GlobalVars.FMDFormat, GlobalVars.FMDVersion));

            if (((emp_dt == null) || (emp_dt.Rows.Count <= 0)) && GlobalVars.StartingUp)
            {
                SyncError = "No se han encontrado colaboradores asignados a la oficina actualmente configurada.";

                return false;
            }
            else
            {
                return true;
            }
        }

        /// <summary>
        /// Recupera los últimos registros de asistencia por empleado, efectuados en la oficina actual.
        /// </summary>
        private async Task GetRecentPunches()
        {
            if (!GlobalVars.BeOffline) {
                emp_punches = await CommonProcs.GetLastPunchesAsync(new ScantRequest { Question = GlobalVars.clockSettings.clock_office.ToString() });

                if (emp_punches == null) {
                    emp_punches = VoidPunches;
                } else {
                    await GlobalVars.AppCache.SaveHistory(emp_punches);
                }
            } else {
                emp_punches = GlobalVars.AppCache.RetrieveHistory();
            }
        }

        /// <summary>
        /// Recupera los avisos emitidos para la oficina actual.
        /// </summary>
        private async Task GetNotices()
        {
            List<NoticeData>? la_salida = [];

            try {
                if (!GlobalVars.BeOffline)
                {
                    var ScantRequest = new ScantRequest { 
                        Question = (GlobalVars.clockSettings.clock_office.ToString()) 
                    };

                    var result = await CommonProcs.GetOfficeNoticesAsync(ScantRequest);
                    List<NoticeData> my_nots = result;

                    if (my_nots != null)
                    {
                        foreach (NoticeData notice in my_nots)
                        {
                            notice.nottit = CommonProcs.Base64ToStr(notice.nottit);
                            notice.notmsg = CommonProcs.Base64ToStr(notice.notmsg);

                            la_salida.Add(notice);
                            Notices.Add(new Notice() {
                                id = notice.notid,
                                caption = notice.nottit,
                                body = notice.notmsg,
                                image = notice.notimg
                            });
                        }

                        await GlobalVars.AppCache.SaveNotices(la_salida);
                    }
                } else {
                    la_salida = GlobalVars.AppCache.RetrieveNotices();
                }

                if (la_salida.Count < 1) la_salida.Add(def_not);
            } catch {
                la_salida = [
                    def_not
                ];
            }
            finally {
               notices = la_salida;
            }

            ParseNotice();
        }

        private async void AddNewNotice(Notice? notice)
        {
            await GetNotices();
        }

        /// <summary>
        /// Agrega un aviso al recuperar el registro en tiempo real desde el servidor de WebSocket
        /// </summary>
        public async Task SetNotice(NoticeData notice)
        {
            //tmrNotices.Stop();
            //tmrNotices.Enabled = false;
            //pnlNotBody.Controls.Clear();

            await GetNotices();
            //tmrNotices.Enabled = true;
            curr_not = 0;
            //List<NoticeData> initial;
            //initial = las_notices;
            //las_notices.Add(notice);
        }

        private void GetOffice()
        {
            Office = (GlobalVars.this_office?.Offname + ".");
        }

        private void SetLogo()
        {
            var logo = GlobalVars.mainSettings?.Logo ?? "";
            if (!string.IsNullOrEmpty(logo)) { 
                LogoImage = ImageHelper.LoadFromResource(logo);
            } else {
                LogoImage = ImageHelper.LoadFromAvares("/Assets/DefaultLogo.png");
            }
        }

        /// <summary>
        /// Inicializa el lector de huella dactilar y lo prepara para la captura.
        /// </summary>
        private void StartReader()
        {
            //if (!GlobalVars.NoFPReader) return;
            try {
                UrUClass.LoadCurrentReader();

                if (!UrUClass.OpenReader()) {
                    KillMe("No se pudo inicializar el Lector de Huellas.");
                }

                if (!UrUClass.StartCaptureAsync(OnCaptured))
                {
                    KillMe("El manejador de evento del Lector de Huella no se puedo asociar.");
                }
            } catch(Exception ex) {
                Dispatcher.UIThread.InvokeAsync(async () => {
                    log.Warn("Error general del Lector de Huellas ==> " + ex.Message);
                    await Show(null, "Lector no encontrado", "No se ha encontrado ningún lector de huella dactilar o no se ha podido tener acceso al mismo.\n\nPruebe una de las siguientes opciones:\n\n1. Rectifique que el lector se encuentra debidamente conectado al equipo; deberá ver una luz azul en el lector que así lo indica.\n2. Asegúrese que los controladores necesarios han sido correctamente instalados.\n3. Conecte y desconecte el lector o conéctelo a un puerto USB diferente.\n4. Reinicie el equipo.\n\nSi el problema persiste, póngase en contacto con el administrador del sistema.\n\nLa aplicación terminará ahora.", MessageBoxButtons.Ok);
                    KillMe("Error general del Lector de Huellas ==> " + ex.Message);
                });
            }
        }
        #endregion

        #region Registros de asistencia
        private async void PunchIt(int found_inx)
        {
            FoundIndex = PwdPunchIndex;
            await Dispatcher.UIThread.InvokeAsync(PunchRegister);
            PwdPunchIndex = -2;
        }

        private async void ShowEventsByEmployee(int selected_inx)
        {
            if (AttsList.Count > 0 && selected_inx != -1) {
                var employee = AttsList[selected_inx];
                var empData = fmd_collection?.Where(x => x.empid == employee.EmpID).First();

                EmpPunches.Clear();

                await Task.Delay(500);
                await UpdateInfoLabels(6, empData.empnum, employee.FullName);
                DataTable dt_punches = await GetEmpPunches(employee.EmpID);

                foreach (DataRow dr in dt_punches.Rows) {
                    DateTime dattim = CommonProcs.FromFileString(dr["PuncTime"].ToString());
                    int.TryParse(dr["EvID"].ToString(), out int el_ev);

                    var data = new EmployeePunch() {
                        punchdate = CommonProcs.UpperFirst(dattim.ToString("dddd dd/MM/yyyy")),
                        punchtime = dattim.ToString("HH:mm:ss"),
                        punchevent = EvTypes[int.Parse(dr["EvID"].ToString() ?? "0")]
                    };

                    EmpPunches.Add(data);
                }
            }
        }

        private async Task PunchRegister()
        {
            try {
                //ToggleTimers(false); //Detiene los temporizadores para calcular el tiempo exacto hasta finalizar el registro
                DateTime client_time = DateTime.Now; //GetRemoteDateTime();
                TimeSpan run_time = GlobalVars.RunningTime.Elapsed;
                DateTime calc_time = GlobalVars.StartTime.Add(run_time);

                await UpdateInfoLabels(4); //Leyenda procesando
                SearchText = "";

                // Si la huella es valida
                if (FoundIndex > -1) // elid_idx
                {
                    FMDItem? emp_finger = fmd_collection?.ElementAt(FoundIndex); //Busca en el listado de huellas de los colaboradores de acuerdo al indice resultante
                    DataTable dt_punches = await GetEmpPunches(emp_finger.empid);

                    int next_ev = 0;
                    //Si el empleado no tiene registros entonces es una entrada
                    if (dt_punches.Rows.Count <= 0) {
                        next_ev = 1;
                    } else {
                        //Si el empleado tiene registros calcula si es entrada o salida
                        PunchLine last_punch = GetLastPunch(dt_punches);
                        next_ev = await ComputeNextEvent(last_punch, client_time);
                    }

                    //Si el registro esta duplicado
                    if (next_ev == -1)
                    {
                        await PlayBeep(4);
                        await UpdateInfoLabels(2);
                        await UpdateNetworkTimeAsync(); // Reconsultar la hora del servidor
                        //ToggleTimers(true); //Reanuda los temporizadores

                        return;
                    }

                    EmpPunches.Clear(); //Limpia el historial de registros del último colaborador

                    await PlayBeep(next_ev);

                    PunchLine new_punch = new() {
                        Punchemp = emp_finger.empid,
                        Punchevent = next_ev,
                        Punchtime = client_time,
                        Punchinternaltime = calc_time
                    };

                    RegisterNewPunch(new_punch, emp_finger);

                    // Muestra los registros de entrada y salida del colaborador actual(DataGridView central)
                    foreach (DataRow dr in dt_punches.Rows)
                    {
                        DateTime dattim = CommonProcs.FromFileString(dr["PuncTime"].ToString());

                        var data = new EmployeePunch() {
                            punchdate = CommonProcs.UpperFirst(dattim.ToString("dddd dd/MM/yyyy")),
                            punchtime = dattim.ToString("HH:mm:ss"),
                            punchevent = EvTypes[int.Parse(dr["EvID"].ToString() ?? "0")]
                        };

                        EmpPunches.Add(data);
                    }

                    await UpdateInfoLabels(1, emp_finger.empnum, emp_finger.empnom, new_punch);

                    //Agrega el nuevo evento del colaborador
                    EmpPunches.Add(new EmployeePunch() {
                        punchdate = CommonProcs.UpperFirst(new_punch.Punchtime.ToString("dddd dd/MM/yyyy")),
                        punchtime = new_punch.Punchtime.ToString("HH:mm:ss"),
                        punchevent = EvTypes[new_punch.Punchevent]
                    });

                    //Muestra el evento registrado del colaborador en el DataGridView de la izquierda
                    //OLD: _sourceList.Add(...)
                    var emp_data = new Employee(
                        emp_finger.empid,
                        emp_finger.empnom,
                        new_punch.Punchtime.ToString("dd/MM/yyyy HH:mm"),
                        EvTypes[new_punch.Punchevent]
                    );

                    if(!IsDuplicated(emp_data)) {
                        AttsList.Add(emp_data);
                    }

                    SelectedIndex = AttsList.Count - 1;
                    SelectedItem = 0;
                    LastEmployeeEventItem = EmpPunches.Count - 1;
                } else {
                    EmpPunches.Clear();
                    await PlayBeep(3);
                    await UpdateInfoLabels(3);
                }

                //ToggleTimers(true); //Reanuda el temporizador esperando otro registro de asistencia.
            } catch (Exception exc) {
                
                //ToggleTimers(true);
                await ShowMessage("Error al procesar la huella", exc.Message);
            } finally {
                await UpdateNetworkTimeAsync();
            }
        }

        /// <summary>
        /// Obtiene el historial de registros de asistencia del colaborador detectado, en el listado de checadas de todos los empleados en una oficina almacenados en memoria.
        /// </summary>
        /// <param name="emp_id"></param>
        /// <returns></returns>
        private async Task<DataTable> OfflineEmpPunches(int emp_id)
        {
            DateTime el_timestamp;
            DataTable dt = VoidPunches;

            try {
                await Task.Run(() =>  {
                    foreach (DataRow dr in emp_punches.Rows)
                    {
                        int el_emp = int.Parse(dr["EmpID"].ToString() ?? "0");

                        if (el_emp == emp_id) {
                            el_timestamp = Convert.ToDateTime(dr["PuncTime"].ToString());

                            dt.Rows.Add(el_emp, dr["EvID"], el_timestamp.ToString("yyyyMMddHHmmss"));
                        }
                    }
                });

                DataView dv = new(dt, "", "PuncTime DESC", DataViewRowState.CurrentRows);
                DataTable dt1 = dv.ToTable().AsEnumerable().Take(10).CopyToDataTable();
                DataView dv2 = new(dt1, "", "PuncTime ASC", DataViewRowState.CurrentRows);

                return dv2.ToTable();
            } catch(Exception ex) { log.Warn("Error fetching punches by employee: " + ex.Message); }

            return dt;
        }

        /// <summary>
        /// Obtiene el historial de registros de asistencia del colaborador directamente de la BD.
        /// </summary>
        /// <returns></returns>
        private static async Task<DataTable> OnlineEmpPunches(int emp_id)
        {
            DataTable dt = VoidPunches;

            try {
                DataTable DBEmpPunches = await CommonProcs.GetLastPunchesAsync(new ScantRequest { Question = GlobalVars.clockSettings.clock_office.ToString() }, emp_id);

                foreach (DataRow dr in DBEmpPunches.Rows)
                {
                    DateTime el_timestamp = Convert.ToDateTime(dr["PuncTime"].ToString());
                    dt.Rows.Add(emp_id, dr["EvID"], el_timestamp.ToString("yyyyMMddHHmmss"));
                }
            } catch { }

            return dt;
        }

        /// <summary>
        /// Obtiene el historial de registros de asistencia del colaborador detectado.
        /// </summary>
        /// <param name="emp_id">ID del colaborador.</param>
        /// <returns>DataTable con el histórico de registros del colaborador.</returns>
        private async Task<DataTable> GetEmpPunches(int emp_id, bool be_offline = true)
        {
            DataTable dt = VoidPunches;
            try {
                dt = be_offline ? await OfflineEmpPunches(emp_id) : await OnlineEmpPunches(emp_id);
            } catch {}

            return dt;
        }

        /// <summary>
        /// Crea un objeto con la información del último registro de asistencia del historial del colaborador detectado.
        /// </summary>
        /// <param name="emp_pncs">DataTable con el histórico de los registros de asistencias del colaborador.</param>
        /// <returns>Objeto PunchLine que encapsula la información del último registro de asistencia encontrado.</returns>
        private static PunchLine GetLastPunch(DataTable emp_pncs)
        {
            DataRow dr = emp_pncs.Rows[^1];

            return new PunchLine {
                Punchemp = int.Parse(dr["EmpID"].ToString() ?? "0"),
                Punchevent = int.Parse(dr["EvID"].ToString() ?? "0"),
                Punchtime = CommonProcs.FromFileString(dr["PuncTime"].ToString())
            };
        }

        /// <summary>
        /// Calcula el siguiente tipo de evento basado en el último evento registrado y los parámetros definidos en la configuración del sistema.
        /// </summary>
        /// <param name="last_punch">Objeto con la información del último registro de asistencia.</param>
        /// <param name="new_punch">Momento del nuevo evento de asistencia.</param>
        /// <returns>El valor del elemento del arreglo EvTypes correspondiente al siguiente evento calculado.</returns>
        private static async Task<int> ComputeNextEvent(PunchLine last_punch, DateTime new_punch)
        {
            TimeSpan ev_diff = new_punch.Subtract(last_punch.Punchtime);
            //Validar si ya cumplió el tiempo estipulado para no considerarlo como duplicado
            if (ev_diff.TotalSeconds < CommonProcs.ParamInt(3)) {
                return -1;
            }

            try {
                switch (last_punch.Punchevent)
                {
                    case 2: //Si es salida
                        //Podría presentarse el caso de que marque "Entrada" cuando sea "Salida" debido a un fallo de sincronización de datos
                        //Normalmente la salida es a las 5:05, entonces validamos si la hora actual es mayor o igual a las 5.
                        int _evt = 1;

                        //if (new_punch.Hour >= 17) {
                        //    _evt = -1;
                        //    await PlayBeep(4);

                        //    var MainWindow = (Application.Current?.ApplicationLifetime as IClassicDesktopStyleApplicationLifetime)?.MainWindow;
                        //    var windows = MainWindow?.OwnedWindows;
                        //    if (MainWindow is { } mainWindow && windows.Count == 0) {
                        //        var dialog = new EventPromptWindow() {
                        //            DataContext = new EventPromptViewModel(TimeSpan.Zero)
                        //        };

                        //        Messenger.Send("TogglePanel", true);
                        //        _evt = await dialog.ShowDialog<int>(mainWindow);
                        //        Messenger.Send("TogglePanel", false);
                        //    }
                        //}

                        return _evt; //Entonces es entrada

                    case 1: //Si es entrada
                        TimeSpan max_shift = CommonProcs.ParamTSpan(12);
                        //En caso de que hayas registrado entrada pero no salida. Ya paso más tiempo de lo permitido.

                        if (ev_diff > max_shift) {
                            int evt = -1;

                            var MainWindow = (Application.Current?.ApplicationLifetime as IClassicDesktopStyleApplicationLifetime)?.MainWindow;
                            var windows = MainWindow?.OwnedWindows;

                            if (MainWindow is { } mainWindow && windows.Count == 0) {
                                var dialog = new EventPromptWindow() {
                                    DataContext = new EventPromptViewModel(max_shift)
                                };

                                Messenger.Send("TogglePanel", true);
                                evt = await dialog.ShowDialog<int>(mainWindow);
                                Messenger.Send("TogglePanel", false);
                            }

                            return evt;
                        } else {
                            return 2; //Devuelve salida
                        }

                    case 0:
                        return 0;

                    default:
                        return 0;
                }
            } catch {
                return 0;
            }
        }

        /// <summary>
        /// Almacena el nuevo registro de asistencia en memoria. Además, si el cliente Checador esta conectado al servidor WebSocket, registra en tiempo real el evento indicado en la BD, en caso contrario, lo guarda en caché, en espera de su sincronización.
        /// </summary>
        /// <param name="new_punch">Objeto con la información del nuevo registro de asistencia.</param>
        private void RegisterNewPunch(PunchLine new_punch, FMDItem? emp = null)
        {
            log.Info("El empleado "+ emp.empnom +" ha registrado " + EvTypes[new_punch.Punchevent] + " a las " + new_punch.Punchtime.ToString("HH:mm:ss") + " horas.");

            emp_punches.Rows.Add(new_punch.Punchemp.ToString(), new_punch.Punchevent.ToString(), new_punch.Punchtime.ToString("yyyy/MM/dd HH:mm:ss"), new_punch.Punchinternaltime.ToString("yyyy/MM/dd HH:mm:ss"));
            GlobalVars.AppCache.StorePunch(new_punch);

            if (IsNetConnected) {
                try
                {
                    Dispatcher.UIThread.InvokeAsync(async () => await SavePunchToDB(new_punch));
                }
                catch (Exception ex)
                {
                    log.Error("Error registering punch: " + ex.Message);
                }

                if (m_settings.UsePusher) {
                    _WSClient.StorePunch(new_punch, emp);
                } 
                else
                {
                   Dispatcher.UIThread.InvokeAsync(async () => await _signalRClient.SendMessageAsync(new_punch, emp) );
                }
            }
        }

        private async Task SavePunchToDB(PunchLine new_punch)
        {
            ScantRequest scantreq = new() {
                Question = (
                    (c_settings?.clock_office).ToString() + "|" +
                    new_punch.Punchemp.ToString() + "|" +
                    new_punch.Punchevent + "|" +
                    new_punch.Punchtime.ToString("yyyy/MM/dd HH:mm:ss") + "|" +
                    new_punch.Punchinternaltime.ToString("yyyy/MM/dd HH:mm:ss")
                )
            };

            if (!await CommonProcs.PunchRegisterAsync(scantreq))
            {
               log.Warn("The event of the employee with ID " + new_punch.Punchemp + " could not be registered.");
            }
        }

        /// <summary>
        /// Envía los registros de asistencia almacenados en caché al servidor.
        /// </summary>
        private Task<bool> UploadPunches()
        {
            tmrSyncRetry.IsEnabled = false;

            if (!GlobalVars.BeOffline) {
                try {
                    string[] from_file = GlobalVars.AppCache.GetCachedPunches(2);

                    if (from_file.Length > 0) {
                        ScantRequest la_req = new() {
                            Question = (
                                GlobalVars.clockSettings.clock_office.ToString() + "." +
                                CommonProcs.ZipString(string.Join(GlobalVars.SeparAtor[0].ToString(), from_file))
                            )
                        };

                        if (CommonProcs.SendPunches(la_req)) {
                            GlobalVars.AppCache.PurgeCachedPunches(2);
                            log.Info($"Se sincronizaron correctamente {from_file.Length} registro(s) de empleados.");



                            return Task.FromResult(true);
                        } else {
                            SyncError = "El servidor ha reportado un problema al procesar los registros de asistencia. Favor de comunicarse con el administrador del sistema.";
                            log.Warn("El servidor ha reportado un problema al procesar los registros de asistencia.");
                            tmrSyncRetry.IsEnabled = true;

                            return Task.FromResult(false);
                        }
                    }
                    else {
                        return Task.FromResult(true);
                    }
                } catch (Exception exc) {
                    SyncError = "Ha ocurrido un fallo al sincronizar los registros de asistencia. Favor de comunicarse con el administrador del sistema.";
                    tmrSyncRetry.IsEnabled = true;
                    log.Error(exc, SyncError);

                    return Task.FromResult(false);
                }
            } else {
                tmrSyncRetry.IsEnabled = true;
                return Task.FromResult(true);
            }
        }
        #endregion

        #region Avisos

        /// <summary>
        /// Muestra la información del anuncio correspondiente al índice actual.
        /// </summary>
        private void ParseNotice()
        {
            try
            {
                NoticeData la_notice = notices[curr_not];
                bool has_text = !(string.IsNullOrWhiteSpace(la_notice.notmsg) || (la_notice.notmsg == "null"));
                bool has_image = !(string.IsNullOrWhiteSpace(la_notice.notimg) || (la_notice.notimg == "null"));

                //pnlNotBody.Controls.Clear();

                if (has_image) {
                    NoticeImage = CommonProcs.Base64ToBitmap(la_notice.notimg ?? "");
                }

                if (has_text)
                {
                    NoticeBody = la_notice.notmsg ?? "";
                }

                NoticeTitle = la_notice.nottit ?? "";
                SetNextNotice();
                if (NoticeCollectionEmpty) tmrNotices.Stop();
            }
            catch (Exception ex)
            {
                log.Warn("Error while showing Notice: " + ex.Message);
            }
        }

        /// <summary>
        /// Establece el siguiente índice del ciclo de avisos.
        /// </summary>
        private static void SetNextNotice()
        {
            curr_not = ((curr_not + 1) >= notices.Count) ? 0 : (curr_not + 1);
        }
        #endregion

        #region Acciones del formulario
        /// <summary>
        /// Configura el reloj y su temporizador.
        /// </summary>
        private async Task SetClock()
        {
            var data = await GetTimeNow();
            CurrentRemoteTime = data;
            CurrentTime = data.TimeString!;
            CurrentLongDate = TodayLongDate;

            StartClock();
        }

        private void StartClock()
        {
            //new DispatcherTimer(TimeSpan.FromSeconds(1), DispatcherPriority.Normal, TimerTick).Start();

            tmrCachedTime = new DispatcherTimer {
                Interval = TimeSpan.FromSeconds(1)
            };
            tmrCachedTime.Tick += TmrCachedTime_Tick;
            tmrCachedTime.Start();

            tmrClock.Interval = TimeSpan.FromSeconds(1);
            tmrClock.Tick += ParseTick;
            tmrClock.Start();
        }

        /// <summary>
        /// Calcula la hora actual del servidor NTP y lo guarda en caché. Después, avanza la hora en caché cada segundo.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private async void TmrCachedTime_Tick(object? sender, EventArgs e)
        {
            // Obtener la hora del servidor NTP solo si no hay una hora en caché
            //if (GlobalVars.CachedTime == DateTime.MinValue) {
            //var data = await GetTimeNow();
            //GlobalVars.CachedTime = data.CurrentTime;
            //}

            // Avanzar la hora basada en la última sincronización con NTP
            CacheCalculatedTime = CacheCalculatedTime.AddSeconds(1);
            GlobalVars.CachedTime = CacheCalculatedTime;

            // Verifica cada 5 minutos si hay una gran diferencia con la hora real
            if ((DateTime.UtcNow - lastUpdateTime).TotalMinutes >= 5) {
                await UpdateNetworkTimeAsync();
                log.Info("La Sincronización de horario programado se ha actualizado!");
            }

            // Si la sincronización ha fallado por más de 1 hora, alerta al usuario
            if (failedAttempts > 12)
            {
                log.Warn("Advertencia: No se ha podido sincronizar la hora en más de 1 hora.");
            }
        }

        /// <summary>
        /// Actualiza la hora del sistema con la hora del servidor NTP en caché. Si la consulta falla, mantiene la última hora calculada.
        /// </summary>
        /// <returns></returns>
        private async Task UpdateNetworkTimeAsync()
        {
            lastUpdateTime = DateTime.UtcNow;

            var networkTime = await GetDateTime();
            if (networkTime == DateTime.MinValue) // Si la consulta NTP falla
            {
                log.Warn("No se pudo obtener la hora del servidor NTP. Manteniendo la última hora calculada.");
                failedAttempts++;
                return; // No cambia nada, sigue usando la última hora calculada
            }

            failedAttempts = 0; // Resetea los intentos fallidos
            lastNetworkTime = networkTime;
            networkOffset = lastNetworkTime - DateTime.UtcNow;

            // Si la diferencia es mayor a 5 segundos, actualizar la hora inmediatamente
            if (Math.Abs((lastNetworkTime - CacheCalculatedTime).TotalSeconds) > 5)
            {
                log.Info("Actualizando la hora del sistema con la hora del servidor NTP.");
                CacheCalculatedTime = lastNetworkTime;
            }
        }

        /// <summary>
        /// Inicia o detiene los temporizadores.
        /// </summary>
        /// <param name="startstop">True para iniciar los temporaizadores, False para detenerlos.</param>
        private void ToggleTimers(bool startstop = true)
        {
            tmrNotices.IsEnabled = startstop;
            tmrClock.IsEnabled = startstop;
        }

        /// <summary>
        /// Termina la aplicación.
        /// </summary>
        private void KillMe(string reason = "")
        {
            forceexit = true;
            GlobalVars.ForceExit = forceexit;
            log.Info("Se ha forzado el cierre de la aplicación." + (reason != "" ? (" " + reason): ""));
            Dispatcher.UIThread.InvokeAsync(async () => {
                await new MainWindow().LogOut(forceexit);
            });
        }

        /// <summary>
        /// Abre el cuadro de diálogo de Sincronización Manual.
        /// </summary>
        private void InvokeManualSyncEvt(bool sync = true)
        {
            Dispatcher.UIThread.InvokeAsync(async() => {
                await InvokeManualSync();
                KillMe("Sincronización manual de eventos activado.");
            });
        }

        private async Task InvokeManualSync()
        {
            if (CommonValids.InvokeLogin(GlobalVars.ClockSyncPriv)) {
                await SyncWithLoader();
                //await Task.Delay(2000);
                GlobalVars.ForceExit = true;
            }
        }

        /// <summary>
        /// Evalúa la operación a ejecutar cada vez que se actualiza el reloj.
        /// </summary>
        private void ParseTick(object? sender, EventArgs e)
        {
            if (CheckSyncDTime()) {
                ScheduleTriggered = true;
                Dispatcher.UIThread.InvokeAsync(async () => {
                    await SyncWithLoader();
                    await SendEmployeesWithNoCheckInOut();
                });
            }

            Dispatcher.UIThread.InvokeAsync(() => {
                CurrentRemoteTime = new RemoteTime {
                    CurrentTime = DateTime.Now, //GlobalVars.CachedTime,
                    TimeString = DateTime.Now.ToString("HH:mm:ss")
                };

                CurrentTime = CurrentRemoteTime.TimeString;
            });

            CurrentLongDate = TodayLongDate; //IMPORTANTE! YA QUE SI LA APP NO SE CIERRA SIEMPRE MOSTRARA LA ULTIMA FECHA DE EJECUCION DE LA APP
            IsWebSocketConnected = m_settings.UsePusher ? WSClient.IsPusherConnected() : _signalRClient.IsConnected;
        }

        /// <summary>
        /// Enviar al correo configurado el listado de empleados que no han registrado entrada o salida en la oficina actual.
        /// </summary>
        /// <returns></returns>
        private static async Task SendEmployeesWithNoCheckInOut()
        {
            var offId = GlobalVars.this_office?.Offid ?? 0;
            var offName = GlobalVars.this_office?.Offname ?? "";

            var dt = await DBMethods.GetEmployeesWithNoCheckInOut(offId);
            var duplicatedPunches = await DBMethods.GetDuplicatedPunches(offId);

            var body = EmailSenderHandler.BuildMessage(dt, duplicatedPunches);

            if (dt.Rows.Count > 0 && dt.Columns.Contains("ERROR") && dt.Rows[0]["ERROR"].ToString() != "None") {
                return;
            }

            if(dt.Rows.Count <= 0) {
                return;
            }

            await Task.Run(async () => {
                await EmailSenderHandler.SendEmailAsync((!string.IsNullOrEmpty(offName) ? offName + " - ": "") + "Control de Asistencia", body);
            });
        }

        /// <summary>
        /// Evento TICK del temporizador de los avisos.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void TmrNotices_Tick(object? sender, EventArgs e)
        {
            ParseNotice();
        }

        /// <summary>
        /// Evento TICK del temporizador del reintento de sincronización.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void TmrSyncRetry_Tick(object? sender, EventArgs e)
        {
            if(!ScheduleTriggered) {
                RetryingSync = true;
                Dispatcher.UIThread.InvokeAsync(async () => await SyncWithLoader());
            }
        }

        /// <summary>
        /// Evalúa si es hora de iniciar la sincronización automática, según los parámetros de configuración del sistema.
        /// </summary>
        /// <returns>True si la hora actual coincide con la configurada en el parámetro correspondiente.</returns>
        private bool CheckSyncDTime()
        {
            DateTime sync_sched = CommonProcs.ParamDTime(2);
            var remote = CurrentRemoteTime.CurrentTime;

            return remote.Date > LastSyncDate.Date && remote.Hour == sync_sched.Hour && (remote.Minute == sync_sched.Minute) && !RetryingSync;
        }

        /// <summary>
        /// Inicia la sincronización del formulario, mostrando el cuadro de carga.
        /// </summary>
        /// <param name="el_msg">Texto (opcional) que sobreescribirá el mensaje predeterminado de la ventana de carga.</param>
        private async Task<bool> SyncWithLoader()
        {
            ToggleTimers(false);

            var MainWindow = (Application.Current?.ApplicationLifetime as IClassicDesktopStyleApplicationLifetime)?.MainWindow;
            string mssg = "Sincronizando, por favor espere...";
            var _window = new LoaderWindow() {
                DataContext = new LoaderViewModel(mssg)
            };

            if (MainWindow.Name == "wdw_Main") {
               _ = _window.ShowDialog(MainWindow);
            }

            IsSyncing = true;
            bool sync_resp = await SyncAll();
            IsSyncing = false;

            if (!sync_resp) await ShowMessage("Problema al sincronizar", SyncError, -1, 150);
            HideLoader();

            ToggleTimers(true);

            return sync_resp;
        }

        private void HideLoader() { 
            var MainWindow = (Application.Current?.ApplicationLifetime as IClassicDesktopStyleApplicationLifetime)?.MainWindow;
            var windows = MainWindow?.OwnedWindows;
            var LoaderWindow = windows?.Where(x => x.Name == "xLoaderWindow").FirstOrDefault();

            if ((MainWindow.Name == "wdw_Main") && windows.Count > 0 && LoaderWindow != null && !IsSyncing)
            {
                foreach (var window in windows) {
                    window.Close();
                }
            }
        }

        /// <summary>
        /// Muestra el cuadro de carga asincrónicamente.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void BgwLoader_DoWork(object? sender, DoWorkEventArgs e)
        {
            string? el_msg = (string?)e.Argument;

            //Dispatcher.UIThread.InvokeAsync(async () => {
            //    var _window = new LoaderWindow() {
            //        DataContext = new LoaderViewModel(el_msg)
            //    };

            //    if ((Application.Current?.ApplicationLifetime as IClassicDesktopStyleApplicationLifetime)?.MainWindow is { } mainWindow) {
            //        await _window.ShowDialog(mainWindow);
            //    }
            //});
        }

        /// <summary>
        /// Carga y reproduce el sonido indicado, de acuerdo al tipo de evento, como retroalimentación del registro de asistencia.
        /// </summary>
        /// <param name="beepType">Sonido que será reproducido.</param>
        public static async Task PlayBeep(int beepType = 0)
        {
            try {
                await Dispatcher.UIThread.InvokeAsync(() => {
                    StopSound();

                    // Crear instancias de reproducción
                    var beepFile = GlobalVars.AppWorkPath + @"Assets\\Audio\\Punch" + PunchSounds[beepType] + ".wav";
                    waveOutEvent = new WaveOutEvent();
                    waveOutEvent.Init(new WaveFileReader(beepFile));
                    waveOutEvent.Play();
                });
            }
            catch (Exception ex) {
                log.Warn($"Error al reproducir sonido: {ex.Message}");
            }
        }

        /// <summary>
        /// Detener la reproducción actual si ya se está reproduciendo
        /// </summary>
        private static void StopSound()
        {
            if (waveOutEvent != null) {
                // Verificar si está reproduciendo antes de detener
                if (waveOutEvent.PlaybackState == PlaybackState.Playing) {
                    waveOutEvent.Stop();
                }
                
                waveOutEvent.Dispose();
                waveOutEvent = null; // Importante: establecer a null despuús de desechar
            }
        }

        /// <summary>
        /// Llena el panel del histórico de registros de asistencia con las que fueron encontradas para el día actual.
        /// </summary>
        private async Task UpdateHistoryPanel()
        {
            int emp_idx = -1;
            string? emp_name = string.Empty;

            DateTime today = GetRemoteDateTime();

            var filteredRows = emp_punches?.AsEnumerable()
            .Where(p => Convert.ToDateTime(p["PuncTime"].ToString()) >= new DateTime(today.Year, today.Month, today.Day, 0, 0, 0))
            .GroupBy(row => new { 
                EmpID = row.Field<int>("EmpID"), 
                EvID = row.Field<int>("EvID"),
                PuncTime = row.Field<string>("PuncTime")
            })
            .Select(group => group.First())
            .OrderBy(x => x.Field<int>("EmpID"))
            //.Take(40)
            .ToList();

            if (filteredRows != null && filteredRows.Any())
            {
                try {
                    // Copy the filtered rows to a new DataTable and sort by "PuncTime"
                    DataTable dt = new DataView(filteredRows.CopyToDataTable(), "", "PuncTime ASC", DataViewRowState.CurrentRows).ToTable();

                    AttsList.Clear();
                    EmpPunches.Clear();
                    Employee.ResetAndReloadData();

                    foreach (DataRow dr in dt.Rows) {
                        emp_idx = fmd_collection.FindIndex(e => e.empid == dr.Field<int>("EmpID"));
                        emp_name = (emp_idx > -1) ? fmd_collection.ElementAt(emp_idx)?.empnom : string.Empty;

                        if (!string.IsNullOrWhiteSpace(emp_name)) {
                            DateTime.TryParse(dr["PuncTime"].ToString(), out DateTime PuncTime);

                            //OLD: _sourceList.Add(...)
                            AttsList.Add(new Employee(
                               dr.Field<int>("EmpID"),
                               emp_name,
                               PuncTime.ToString("dd/MM/yyyy HH:mm"),
                               EvTypes[dr.Field<int>("EvID")]
                            ));
                        }
                    }

                    SelectedIndex = AttsList.Count - 1;//_sourceList.Count - 1;
                    SelectedItem = 0;
                } catch (Exception ex) {
                    log.Error(new Exception(), "Error al llenar el panel del histórico de registros de asistencia: " + ex);
                }
            }

            await UpdateInfoLabels(5);
        }

        /// <summary>
        /// Consolida los registros de asistencia almacenados en caché con los recuperados del histórico, para poblar el panel histórico de la aplicación.
        /// </summary>
        private async Task ConsolidateHistory()
        {
            await GetRecentPunches();
            string[] cached_punches = GlobalVars.AppCache.GetCachedPunches(2);
            string[] punch_parts;

            foreach (string str in cached_punches)
            {
                punch_parts = str.Split(['|']);

                int EmpID = int.Parse(punch_parts[0]);
                int EvID = int.Parse(punch_parts[1]);
                string? PuncTime = (punch_parts.Length > 2) ? CommonProcs.ParseValidDT(punch_parts[2], "yyyy/MM/dd HH:mm:ss") : null;
                string? PuncCalc = (punch_parts.Length > 3) ? CommonProcs.ParseValidDT(punch_parts[3], "yyyy/MM/dd HH:mm:ss") : null;

                //emp_punches.Rows.Add(EmpID, EvID, DateTime.Parse(punch_parts[2]), PuncCalc);
                emp_punches.Rows.Add(EmpID, EvID, PuncTime, PuncCalc);
            }
        }

        private readonly TimeSpan normalInterval = TimeSpan.FromSeconds(30);
        private readonly TimeSpan offlineInterval = TimeSpan.FromSeconds(5);
        private bool lastConnectionState = true;

        /// <summary>
        /// Configura los intervalos para los temporizadores de la aplicación.
        /// <para>1) Temporizador para intentos de sincronización de registros.</para>
        /// <para>2) Temporizador para mostrar Avisos.</para>
        /// <para>3) Temporizador para verificar la conexión a Internet.</para>
        /// </summary>
        private void ConfigTimers()
        {
            int retrymins = CommonProcs.ParamInt(11); //Retry interval in minutes

            retrymins = (retrymins < 10) ? 10 : retrymins;
            tmrSyncRetry.Interval = TimeSpan.FromMilliseconds(retrymins * 60 * 1000);
            tmrSyncRetry.Tick += TmrSyncRetry_Tick;
            tmrSyncRetry.Start();

            tmrNotices.Interval = TimeSpan.FromMilliseconds(CommonProcs.ParamInt(9) * 1000);
            tmrNotices.Tick += TmrNotices_Tick;
            tmrNotices.Start();

            tmrCheckNetConnection.Interval = normalInterval;
            tmrCheckNetConnection.Tick += async (sender, e) => await ToggleConnIndicator();
            tmrCheckNetConnection.Start();
        }

        /// <summary>
        /// Actualiza el estado de la conexion a Internet en la Pantalla del Checador.
        /// </summary>
        /// <returns></returns>
        private async Task ToggleConnIndicator()
        {
            bool isLocalNetworkAvailable = NetworkInterface.GetIsNetworkAvailable();
            var IsOnline = await CommonValids.ValidInternetConnAsync();

            NetworkConStatus = IsOnline ? "Conectado" : "Sin conexión";
            IsNetConnected = IsOnline;
            GlobalVars.BeOffline = !IsOnline;

            // Ajustar el intervalo según el estado de la conexión
            if (IsOnline != lastConnectionState)
            {
                tmrCheckNetConnection.Interval = IsOnline ? normalInterval : offlineInterval;
                lastConnectionState = IsOnline;
            }
        }
        #endregion

        #region Manejadores de eventos
        /// <summary>
        /// Procesa la huella capturada por el lector.
        /// </summary>
        /// <param name="captureResult">Datos capturados por el lector.</param>
        public void OnCaptured(CaptureResult captureResult)
        {
            IDThreshold = CommonProcs.ParamInt(7) * 1 / CommonProcs.ParamInt(8);

            // Check capture quality and throw an error if bad.
            if (!UrUClass.CheckCaptureResult(captureResult)) return;

            DataResult<Fmd> preIdentify = FeatureExtraction.CreateFmdFromFid(captureResult.Data, Constants.Formats.Fmd.ISO);
            IdentifyResult identified = Comparison.Identify(preIdentify.Data, 0, las_fmds, IDThreshold, 1);

            if (identified.ResultCode == Constants.ResultCode.DP_SUCCESS) {
                elid_idx = (identified.Indexes.Length > 0) ? identified.Indexes[0][0] : -1;
                FoundIndex = elid_idx;
                Dispatcher.UIThread.InvokeAsync(PunchRegister);
                //UrUClass.ControlControls(4, btnParseID);
            } else if (identified.ResultCode == Constants.ResultCode.DP_DEVICE_BUSY) {
                Dispatcher.UIThread.InvokeAsync(async () => {
                    await ShowMessage("El lector no responde", "El lector de huella dactilar está ocupado y no responde en estos momentos. Por favor, espere unos segundos e inténtelo de nuevo");
                });
            } else {
                forceexit = true;
                Dispatcher.UIThread.InvokeAsync(async() => {
                    await ShowMessage("Fallo del lector", "Ha ocurrido un fallo con el lector de huella dactilar o ha dejado de ser reconocido por el sistema.\n\nLa aplicación no puede continuar y se cerrará ahora.", -1, -1, SizeToContent.Height);
                    KillMe("Fallo del Lector dactilar o ha dejado de ser reconocido por el sistema.");
                });
                //UrUClass.ControlControls(3, this);
            }
        }

        /// <summary>
        /// Maximiza la ventana después del evento LOAD.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private async Task FormShown()
        {
            //WindowState = FormWindowState.Maximized;
            await StarterSync();

            if (GlobalVars.SyncOnly) KillMe("Cierre después de sincronizar las checadas en el evento FormShown.");
        }

        /// <summary>
        /// Detiene el lector de huella y libera los recursos tras el cierre del formulario.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void CloseReader()
        {
            UrUClass.CancelCaptureAndCloseReader(OnCaptured);
        }
        #endregion

        #region Objetos dinómicos
        private CancellationTokenSource _cancellationTokenSource = new();
        /// <summary>
        /// Actualiza las etiquetas(Leyendas) al procesar la información de eventos.
        /// </summary>
        /// <param name="la_action">La acción a la que se hace referencia.</param>
        /// <param name="emp_num">Número del colaborador.</param>
        /// <param name="emp_nom">Nombre del colaborador.</param>
        /// <param name="la_punch">Objeto que encapsula la información del registro de asistencia.</param>
        private async Task UpdateInfoLabels(int la_action, string? emp_num = null, string? emp_nom = null, PunchLine? la_punch = null)
        {
            string txtlblName = "";
            string txtlblEvent;

            _cancellationTokenSource.Cancel(); // Cancel any previous delay
            _cancellationTokenSource = new CancellationTokenSource(); // Create a new CancellationTokenSource

            try {
                await Task.Delay(200, _cancellationTokenSource.Token); // Use the new token
            } catch (TaskCanceledException) {
                return; // Exit if the delay was canceled
            }

            switch (la_action)
            {
                case 6: //Solo muestra información
                    txtlblName = emp_num + " - " + emp_nom;
                    txtlblEvent = "Esperando huella...";
                    break;
                case 5: //Esperando
                    txtlblName = string.Empty;
                    txtlblEvent = "Esperando huella...";
                    break;

                case 4: //Procesando
                    txtlblName = "Procesando...";
                    txtlblEvent = "Espere...";
                    break;

                case 3: //Huella no encontrada
                    txtlblName = "No se encontró su huella";
                    txtlblEvent = "Por favor, inténtelo de nuevo.";
                    break;

                case 2: //Registro duplicado
                    var allowed_time = CommonProcs.ParamInt(3);
                    string secs_str = (allowed_time == 1) ? "segundo." : (allowed_time + " segundos.");

                    txtlblName = "Registro duplicado";
                    txtlblEvent = "Sólo puede generar un registro cada " + secs_str;
                    break;

                case 1: //Registro correcto
                    try {
                        txtlblName = emp_num + " - " + emp_nom;
                        txtlblEvent = EvTypes[la_punch.Punchevent] + " registrada a las " + la_punch.Punchtime.ToString("HH:mm:ss") + " horas.";
                        break;
                    } catch(Exception ex) {
                        log.Warn("Error al procesar datos de checada: ", ex.Message);
                        await UpdateInfoLabels(0);
                        return;
                    }

                case 0: //Limpia etiquetas
                    txtlblName = string.Empty;
                    txtlblEvent = string.Empty;
                    break;

                default:
                    return;
            }

            EmployeeName = txtlblName;
            EmployeeEvent = txtlblEvent;
        }
        #endregion
    }

    /// <summary>
    /// PageTransitions are used to render a transition between two views, for example in a Carousel or TransitioningContentControl
    /// <para>The duration must be set before the transition is used and must be greater than 0. If not, you will get an error.</para>
    /// </summary>
    public class PageTransition : ViewModelBase
    {
        public PageTransition(string displayTitle)
        {
            DisplayTitle = displayTitle;
        }

        public string DisplayTitle { get; }


        private IPageTransition? _Transition;

        /// <summary>
        /// Gets or sets the transition
        /// </summary>
        public IPageTransition? Transition
        {
            get { return _Transition; }
            set { this.RaiseAndSetIfChanged(ref _Transition, value); }
        }

        public override string ToString()
        {
            return DisplayTitle;
        }

    }

    /// <summary>
    /// You can also create your own PageTransition by implementing the IPageTransition-interface.
    /// </summary>
    public class CustomTransition : IPageTransition
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="CustomTransition"/> class.
        /// </summary>
        public CustomTransition()
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="CustomTransition"/> class.
        /// </summary>
        /// <param name="duration">The duration of the animation.</param>
        public CustomTransition(TimeSpan duration)
        {
            Duration = duration;
        }

        /// <summary>
        /// Gets the duration of the animation.
        /// </summary>
        public TimeSpan Duration { get; set; }

        public async Task Start(Visual? from, Visual? to, bool forward, CancellationToken cancellationToken)
        {
            if (cancellationToken.IsCancellationRequested)
            {
                return;
            }

            var tasks = new List<Task>();
            var parent = GetVisualParent(from, to);
            var scaleProperty = ScaleTransform.ScaleYProperty;

            if (from != null)
            {
                var animation = new Animation {
                    FillMode = FillMode.Forward,
                    Children = {
                        new KeyFrame
                        {
                            Setters = { new Setter { Property = scaleProperty, Value = 1d } },
                            Cue = new Cue(0d)
                        },
                        new KeyFrame
                        {
                            Setters =
                            {
                                new Setter
                                {
                                    Property = scaleProperty,
                                    Value = 0d
                                }
                            },
                            Cue = new Cue(1d)
                        }
                    },
                    Duration = Duration
                };
                tasks.Add(animation.RunAsync(from, cancellationToken));
            }

            if (to != null)
            {
                to.IsVisible = true;
                var animation = new Animation {
                    FillMode = FillMode.Forward,
                    Children = {
                        new KeyFrame
                        {
                            Setters =
                            {
                                new Setter
                                {
                                    Property = scaleProperty,
                                    Value = 0d
                                }
                            },
                            Cue = new Cue(0d)
                        },
                        new KeyFrame
                        {
                            Setters = { new Setter { Property = scaleProperty, Value = 1d } },
                            Cue = new Cue(1d)
                        }
                    },
                    Duration = Duration
                };
                tasks.Add(animation.RunAsync(to, cancellationToken));
            }

            await Task.WhenAll(tasks);

            if (from != null && !cancellationToken.IsCancellationRequested)
            {
                from.IsVisible = false;
            }
        }

        /// <summary>
        /// Gets the common visual parent of the two control.
        /// </summary>
        /// <param name="from">The from control.</param>
        /// <param name="to">The to control.</param>
        /// <returns>The common parent.</returns>
        /// <exception cref="ArgumentException">
        /// The two controls do not share a common parent.
        /// </exception>
        /// <remarks>
        /// Any one of the parameters may be null, but not both.
        /// </remarks>
        private static Visual GetVisualParent(Visual? from, Visual? to)
        {
            var p1 = (from ?? to)!.GetVisualParent();
            var p2 = (to ?? from)!.GetVisualParent();

            if (p1 != null && p2 != null && p1 != p2)
            {
                throw new ArgumentException("Controls for PageSlide must have same parent.");
            }

            return (Visual)(p1 ?? throw new InvalidOperationException("Cannot determine visual parent."));
        }
    }
}
