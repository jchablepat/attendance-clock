using Avalonia.Animation;
using Avalonia.Controls;
using Avalonia.Threading;
using DPUruNet;
using ExCSS;
using Microsoft.AspNetCore.SignalR.Client;
using Microsoft.Extensions.DependencyInjection;
using MsBox.Avalonia.Enums;
using NLog;
using ReactiveUI;
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using System.Data;
using System.Linq;
using System.Net.NetworkInformation;
using System.Reactive;
using System.Reactive.Linq;
using System.Runtime.InteropServices;
using System.Threading;
using System.Threading.Tasks;
using System.Windows.Input;
using VTACheckClock.DBAccess;
using VTACheckClock.Helpers;
using VTACheckClock.Models;
using VTACheckClock.Services;
using VTACheckClock.Services.Libs;
using VTACheckClock.Views;
using static VTACheckClock.Services.CommonObjs;
using static VTACheckClock.Views.MessageBox;
using Bitmap = Avalonia.Media.Imaging.Bitmap;

namespace VTACheckClock.ViewModels
{
    /*public*/
    partial class MainWindowViewModel : ViewModelBase
    {
        public static string Greeting => "Welcome to Avalonia!"; //Code generated by default

        private IRealtimeService? _realtime;
        private string _connectionStatus = "Servidor WebSocket desactivado";
        public string _currentTime = "00:00:00";
        public ClockTimeData? _currentClockTime = new();
        public string _currentLongDate = "";
        public string _networkConStatus = "Sin conexión";
        public string _office = "";
        public string _empName = "";
        public string _empEvent = "Esperando huella...";
        private string? _searchText;
        private string _noticeTitle = "", _noticeBody = "", _platform = "", _syncError = "";
        private bool _IsWSEnabled, _IsWebSocketConnected, _IsNetConnected;
        private int _selectedIndex = 0, _selectedItem = 0, _lastEmployeeEvent = 0;
        private int _foundIndex = -2, _pwdPunchIndex = -2; //-2 Initialized, -1 Not found Index
        private bool _isSyncing = true, _sync = false;
        private Notice? _newNotice;
        private Bitmap? _logoImage;
        private Bitmap? _noticeImage;
        private bool _emptyNotices;

        //private SourceList<Employee> _sourceList = new();
        //private readonly ReadOnlyObservableCollection<Employee> _attsList;
        //public ReadOnlyObservableCollection<Employee> AttsList => _attsList;
        public ObservableCollection<Employee>? AttsList { get; set; } = [];
        public ObservableCollection<Employee> SearchResults { get; } = [];
        public ObservableCollection<EmployeePunch> EmpPunches { get; }
        public ObservableCollection<Notice> Notices { get; }
        public ObservableCollection<FMDItem> FingerPrints { get; }
        public List<PageTransition> PageTransitions { get; } = [];
        public ReactiveCommand<Unit, Unit>? PwdPunchCommand { get; }
        public Interaction<PwdPunchViewModel, int> ShowPwdPunchDialog { get; } = new();
        public Interaction<WebsocketLoggerViewModel, bool> ShowLoggerDialog { get; } = new();
        public Interaction<AttendanceViewModel, bool> ShowAttendanceRptDialog { get; } = new();
        public Interaction<PunchSyncPreviewViewModel, bool> ShowPunchesPreviewDialog { get; } = new();
        public Interaction<LoginViewModel, bool> ShowLoginDialog { get; } = new();
        public ICommand? LoginCommand { get; }
        public ICommand? LogOutCommand { get; }
        public ICommand? PreviewLoggerCommand { get; }
        public ICommand? PreviewAttendanceReportCommand { get; }
        public ICommand? PreviewPunchSyncCommand { get; }
        public ICommand? SyncEvtCommand { get; }

        public ICommand? TestCommand { get; }

        public ICommand SendEmailCommand { get; }

        //public CheckClockMainViewModel? ClockMain { get; } DEPRECATED AND DELETED FILE: USED ONLY WITH "Content"

        ViewModelBase content = new();

        public Bitmap? LogoImage { 
            get => _logoImage;
            set => this.RaiseAndSetIfChanged(ref _logoImage, value);
        }
        
        //public Task<Bitmap?> LogoImageFromWebSite { get; } = ImageHelper.LoadFromWeb(new Uri("https://upload.wikimedia.org/wikipedia/commons/4/41/NewtonsPrincipia.jpg"));
        
        public string CurrentTime
        {
            get => _currentTime;
            set => this.RaiseAndSetIfChanged(ref _currentTime, value);
        }

        /// <summary>
        /// Esta variable es un modelo que almacena la hora remota en formato DateTime y String.
        /// </summary>
        public ClockTimeData? CurrentClockTime
        {
            get => _currentClockTime;
            set => this.RaiseAndSetIfChanged(ref _currentClockTime, value);
        }

        public string CurrentLongDate
        {
            get => _currentLongDate;
            set => this.RaiseAndSetIfChanged(ref _currentLongDate, value);
        }

        public string ConnectionStatus
        {
            get => _connectionStatus;
            set => this.RaiseAndSetIfChanged(ref _connectionStatus, value);
        }

        public bool IsWebSocketEnabled
        {
            get => _IsWSEnabled;
            set {
                this.RaiseAndSetIfChanged(ref _IsWSEnabled, value);
                // Notify derived properties
                this.RaisePropertyChanged(nameof(IsWebSocketDisabled));
                this.RaisePropertyChanged(nameof(IsWebSocketDisconnected));
            }
        }

        public bool IsWebSocketConnected
        {
            get => _IsWebSocketConnected;
            set {
                this.RaiseAndSetIfChanged(ref _IsWebSocketConnected, value);
                // Notify derived property
                this.RaisePropertyChanged(nameof(IsWebSocketDisconnected));
            }
        }

        public string NetworkConStatus
        {
            get => _networkConStatus;
            set => this.RaiseAndSetIfChanged(ref _networkConStatus, value);
        }

        public string Office
        {
            get => _office;
            set => this.RaiseAndSetIfChanged(ref _office, value);
        }

        public bool IsNetConnected
        {
            get => _IsNetConnected;
            set => this.RaiseAndSetIfChanged(ref _IsNetConnected, value);
        }

        public string EmployeeName
        {
            get => _empName;
            set => this.RaiseAndSetIfChanged(ref _empName, value);
        }

        public string EmployeeEvent
        {
            get => _empEvent;
            set => this.RaiseAndSetIfChanged(ref _empEvent, value);
        }

        public int SelectedIndex
        {
            get => _selectedIndex;
            set => this.RaiseAndSetIfChanged(ref _selectedIndex, value);
        }

        public int SelectedItem
        {
            get => _selectedItem;
            set => this.RaiseAndSetIfChanged(ref _selectedItem, value);
        }

        public int LastEmployeeEventItem
        {
            get => _lastEmployeeEvent;
            set => this.RaiseAndSetIfChanged(ref _lastEmployeeEvent, value);
        }

        public bool NoticeCollectionEmpty
        {
            get => _emptyNotices;
            set => this.RaiseAndSetIfChanged(ref _emptyNotices, value);
        }

        public string NoticeTitle
        {
            get => _noticeTitle;
            set => this.RaiseAndSetIfChanged(ref _noticeTitle, value);
        }

        public string NoticeBody
        {
            get => _noticeBody;
            set => this.RaiseAndSetIfChanged(ref _noticeBody, value);
        }

        public Bitmap? NoticeImage
        {
            get => _noticeImage;
            private set => this.RaiseAndSetIfChanged(ref _noticeImage, value);
        }

        public string? SearchText
        {
            get => _searchText;
            set => this.RaiseAndSetIfChanged(ref _searchText, value);
        }

        // Derived state helpers for WS visual conditions
        public bool IsWebSocketDisabled => !IsWebSocketEnabled;
        public bool IsWebSocketDisconnected => IsWebSocketEnabled && !IsWebSocketConnected;

        private PageTransition? _SelectedTransition;

        /// <summary>
        /// Gets or sets the transition to play
        /// </summary>
        public PageTransition? SelectedTransition
        {
            get => _SelectedTransition;
            set { this.RaiseAndSetIfChanged(ref _SelectedTransition, value); }
        }

        private int _Duration = 500;

        /// <summary>
        /// Gets or Sets the duration
        /// </summary>
        public int Duration
        {
            get => _Duration;
            set {
                this.RaiseAndSetIfChanged(ref _Duration, value);
                SetupTransitions();
            }
        }

        public int FoundIndex
        {
            get => _foundIndex;
            set => this.RaiseAndSetIfChanged(ref _foundIndex, value);
        }

        public int PwdPunchIndex
        {
            get => _pwdPunchIndex;
            set => this.RaiseAndSetIfChanged(ref _pwdPunchIndex, value);
        }

        public bool IsSyncing
        {
            get => _isSyncing;
            set => this.RaiseAndSetIfChanged(ref _isSyncing, value);
        }

        public bool ShowLoader
        {
            get => _sync;
            set => this.RaiseAndSetIfChanged(ref _sync, value);
        }

        public Notice? NewNotice
        {
            get => _newNotice;
            set => this.RaiseAndSetIfChanged(ref _newNotice, value);
        }

        public string PlatformInfo {
            get => _platform;
            set => this.RaiseAndSetIfChanged(ref _platform, value);
        }

        public string SyncError
        {
            get => _syncError;
            set => this.RaiseAndSetIfChanged(ref _syncError, value);
        }

        public ViewModelBase Content
        {
            get => content;
            private set => this.RaiseAndSetIfChanged(ref content, value);
        }

        private readonly EmailSenderHandler EmailSender = new();

        public MainWindowViewModel(string? text = null)
        {
            //Content = ClockMain = new CheckClockMainViewModel(FoundIndex);
            AttsList = [];
            EmpPunches = [];
            Notices = [];
            FingerPrints = [];

            AttsList.CollectionChanged += AttsList_CollectionChanged;
            Dispatcher.UIThread.InvokeAsync(async() => {
                await FormInit();
            });

            this.WhenAnyValue(x => x.Notices.Count).Subscribe(x => NoticeCollectionEmpty = x == 0);

            //_sourceList.Connect()
            //.Sort(SortExpressionComparer<Employee>.Ascending(t => t.Index))
            //.Bind(out _attsList)
            //.Subscribe();

            this.WhenAnyValue(x => x.PwdPunchIndex).Where(y => y != -2).Subscribe(PunchIt!);
            //this.WhenAnyValue(x => x.SelectedIndex).Subscribe(ShowEventsByEmployee!);

            LoginCommand = ReactiveCommand.CreateFromTask(InvokeLogin);
            LogOutCommand = ReactiveCommand.CreateFromTask(async() => {
                Messenger.Send("TogglePanel", true);

                var _result = await ShowPrompt("¿Salir?", "¿Confirma que desea salir de la aplicación?");
                if (_result == ButtonResult.Yes) {
                    GlobalVars.ForceExit = true;

                    await InvokeManualSync();
                    await new MainWindow().LogOut(true);
                }

                Messenger.Send("TogglePanel", false);
            });

            PreviewLoggerCommand = ReactiveCommand.CreateFromTask(async () => {
                var frmPassPunc = new WebsocketLoggerViewModel();
                await ShowLoggerDialog.Handle(frmPassPunc);
            });

            PreviewAttendanceReportCommand = ReactiveCommand.CreateFromTask(async () => {
                var vmAtteRptViewModel = new AttendanceViewModel();
                await ShowAttendanceRptDialog.Handle(vmAtteRptViewModel);
            });

            PreviewPunchSyncCommand = ReactiveCommand.CreateFromTask(async () => {
                // Requiere autenticación de administrador similar a ClockSettings
                if (CommonValids.InvokeLogin(GlobalVars.AdminSetPriv))
                {
                    var vm = new PunchSyncPreviewViewModel();
                    await ShowPunchesPreviewDialog.Handle(vm);
                }
            });

            //SyncEvtCommand = ReactiveCommand.CreateFromTask(InvokeManualSync(false));
            this.WhenAnyValue(x => x.ShowLoader).Where(y => y).Subscribe(InvokeManualSyncEvt!);
            this.WhenAnyValue(x => x.NewNotice).Where(y => y != null).Subscribe(AddNewNotice!);
            this.WhenAnyValue(x => x.SearchText).Throttle(TimeSpan.FromMilliseconds(500)).ObserveOn(RxApp.MainThreadScheduler).Subscribe(DoSearch!);

            NetworkChange.NetworkAvailabilityChanged += OnNetworkAvailabilityChanged;

            SendEmailCommand = ReactiveCommand.CreateFromTask(async () => await SendEmployeesWithNoCheckInOut());
        }

        private void AttsList_CollectionChanged(object? sender, NotifyCollectionChangedEventArgs e)
        {
            try {
                if(e.Action == NotifyCollectionChangedAction.Add) {
                    foreach (Employee newItem in e.NewItems)
                    {
                        SearchResults.Add(newItem);
                    }
                }
                else if (e.Action == NotifyCollectionChangedAction.Reset) {
                    SearchResults.Clear();
                }
            }
            catch (Exception ex) {
                log.Warn("Error al actualizar la búsqueda: " + ex.ToString());
            }
        }

        // AddNLogConfiguration ha sido removido: el logging se configura en LoggingService

        /// <summary>
        /// Detectar la plataforma y configurar la detección de cambios en la hora del sistema
        /// </summary>
        private static void GetPlatform()
        {
            if (RuntimeInformation.IsOSPlatform(OSPlatform.Linux))
            {
                // Configurar la detección de cambios en la hora del sistema en Linux (utilizando libnotify, por ejemplo)
            }
            else if (RuntimeInformation.IsOSPlatform(OSPlatform.OSX))
            {
                // Configurar la detección de cambios en la hora del sistema en macOS
            }
        }

        private void SetupTransitions()
        {
            if (PageTransitions.Count == 0)
            {
                PageTransitions.AddRange([
                    new PageTransition("None"),
                    new PageTransition("CrossFade"),
                    new PageTransition("Slide horizontally"),
                    new PageTransition("Slide vertically"),
                    new PageTransition("Composite"),
                    new PageTransition("Custom")
                ]);
            }

            //The "CrossFade" fades out the current view and fades in the new view by animating the opacity.
            PageTransitions[1].Transition = new CrossFade(TimeSpan.FromMilliseconds(Duration));
            // The "PageSlide" slides the content either horizontally or vertically.
            // You can specify the slide axis via the Orientation-property. The default value is Horizontal.
            PageTransitions[2].Transition = new PageSlide(TimeSpan.FromMilliseconds(Duration), PageSlide.SlideAxis.Horizontal);
            PageTransitions[3].Transition = new PageSlide(TimeSpan.FromMilliseconds(Duration), PageSlide.SlideAxis.Vertical);
            //The "CompositePageTransition" is used create a combined transition of several different transitions.
            var compositeTransition = new CompositePageTransition();
            compositeTransition.PageTransitions.Add(PageTransitions[1].Transition!);
            compositeTransition.PageTransitions.Add(PageTransitions[2].Transition!);
            compositeTransition.PageTransitions.Add(PageTransitions[3].Transition!);
            PageTransitions[4].Transition = compositeTransition;

            PageTransitions[5].Transition = new CustomTransition(TimeSpan.FromMilliseconds(Duration));

            _SelectedTransition = PageTransitions[1];
        }

        private bool IsInternetConnected;
        private void OnNetworkAvailabilityChanged(object? sender, NetworkAvailabilityEventArgs e)
        {
            try {
                // Actualizar el estado de conexión a internet
                IsInternetConnected = e.IsAvailable;

                Dispatcher.UIThread.InvokeAsync(async () => {
                    await ToggleConnIndicator();

                    if (IsInternetConnected) {
                        // Esperar durante 5 segundos antes de sincronizar datos
                        await Task.Delay(TimeSpan.FromSeconds(5));

                        // Verificar si la conexión sigue activa antes de sincronizar
                        if (IsInternetConnected) {
                            log.Warn("El equipo se conectó de nuevo a Internet.");

                            await SyncWithLoader();
                            await ReloadWebSocket();
                        } else {
                            log.Warn("La conexión a Internet se perdió nuevamente antes de sincronizar.");
                        }
                    } else { 
                        log.Warn("El equipo se desconectó de Internet.");
                    }
                });
            } catch(Exception ex) {
                IsInternetConnected = false;
                log.Warn("OnNetworkAvailabilityChangedError: " + ex.Message);
            }
        }

        private bool IsDuplicated(Employee? item) => AttsList != null && AttsList.Any(e => e.EventTime == item.EventTime && e.EventType == item.EventType && e.EmpID == item.EmpID);

        #region WebSocket Configuration
        /// <summary>
        /// Configura los eventos del cliente WebSocket.
        /// </summary>
        private void ConfigureWebSocketEvents()
        {
            IsWebSocketEnabled = GlobalVars.mainSettings.Websocket_enabled;
            _realtime = App.ServiceProvider.GetRequiredService<IRealtimeService>();
            _realtime.ConnectionStateChanged += OnHubConnectionStateChanged;
            _realtime.MessageReceived += (_, message) =>
            {
                try { ValidateReceivedPunch(message); }
                catch (Exception ex) { log.Error(ex, "Error al procesar el mensaje recibido"); }
            };
        }

        private async void InitializeWebSocket()
        {
            try
            {
                await _realtime!.InitializeAsync();
            }
            catch (Exception ex)
            {
                log.Error(ex, "Error al inicializar el Servidor WebSocket");
                ConnectionStatus = "Error de conexión";
            }
        }

        private async Task ReloadWebSocket()
        {
            try
            {
                await _realtime!.ReloadAsync();
            }
            catch (Exception ex)
            {
                log.Error(ex, "Error al reconectar el Servidor WebSocket");
            }
        }

        private void OnHubConnectionStateChanged(object? sender, HubConnectionState state)
        {
            ConnectionStatus = state switch {
                HubConnectionState.Connecting => "Conectando al servidor WebSocket...",
                HubConnectionState.Connected => "Servidor WebSocket en línea",
                HubConnectionState.Disconnected => "Servidor WebSocket desconectado",
                HubConnectionState.Reconnecting => "Reconectando Websocket...",
                _ => "Estado desconocido"
            };
            // Reflect connection state for UI conditions
            IsWebSocketConnected = state == HubConnectionState.Connected;
        }
        #endregion WebSocket Configuration

        public static int GetIndexByName(string[] array, string? name)
        {
            var index = Array.IndexOf(array, name);
            return (index != -1) ? index : 0;
        }

        /// <summary>
        /// Muestra una ventana emergente, el cual pregunta si quiere cerrar sesión, únicamente cuando se presiona el botón de "Salir".
        /// </summary>
        /// <returns></returns>
        private async Task InvokeLogin()
        {
             if (GlobalVars.BeOffline) {
                 await ShowMessage("Aplicación sin conexión", "La aplicación se encuentra actualmente en modo 'Fuera de línea'. No es posible reconfigurarla hasta que exista una conexión activa a Internet.", -1, 140);
             } else {
                var frmPassPunc = new LoginViewModel();
                await ShowLoginDialog.Handle(frmPassPunc);
             }
        }

        /// <summary>
        /// Método para buscar un empleado en la lista de checadas en la pantalla principal
        /// </summary>
        /// <param name="s">Nombre del empleado</param>
        private async void DoSearch(string s)
        {
            SearchResults.Clear();

            if (!string.IsNullOrWhiteSpace(s) && AttsList != null)
            {
                var filteredEntries = await Task.Run(() => {
                    return AttsList.Where(entry => entry.FullName.ToLower().Contains(s.ToLower(), StringComparison.OrdinalIgnoreCase)).ToList();
                });

                foreach (var entry in filteredEntries)
                {
                    SearchResults.Add(entry);
                }
            } else if(AttsList != null) {
                foreach (var entry in AttsList)
                {
                    SearchResults.Add(entry);
                }
            }

            SelectedIndex = SearchResults.Count - 1;
        }

        #region Inicialización
        private int IDThreshold = 0; //CommonProcs.ParamInt(7) * 1 / CommonProcs.ParamInt(8)
        private bool forceexit = false;
        private List<Fmd>? las_fmds;
        private List<FMDItem>? fmd_collection;
        private static readonly Logger log = LogManager.GetLogger("app_logger");

        /// <summary>
        /// Inicializa el entorno del formulario.
        /// </summary>
        private async Task FormInit()
        {
            MakeClockSession();
            SetOffice();
            SetLogo();
            StartReader();
            ConfigureWebSocketEvents();
            InitializeWebSocket();
            
            GetPlatform();
            SetupTransitions();
            ConfigTimers();
            ToggleTimers(false);

            await SetClock();
            await UpdateInfoLabels(0);
            await StarterSync();

        }

        /// <summary>
        /// Crea el objeto SessionData que utilizará la interfaz del Reloj Checador.
        /// </summary>
        private static void MakeClockSession()
        {
            GlobalVars.clockSession = new SessionData {
                usrname = GlobalVars.clockSettings?.clock_user,
                passwd = GlobalVars.clockSettings?.clock_pass,
                accpriv = GlobalVars.ClockStartPriv
            };
        }

        /// <summary>
        /// Initializes the clock service, subscribes to its tick events, and updates the current clock time.
        /// </summary>
        /// <remarks>This method retrieves the <see cref="ClockService"/> instance from the application's
        /// service provider. If the service is not available, a new instance is created. The method subscribes to the
        /// clock's tick events and updates the <c>CurrentClockTime</c> property with the clock's time data after
        /// initialization.</remarks>
        /// <returns></returns>
        private async Task SetClock()
        {
            // Inicializar servicio de reloj y suscribirse a sus ticks
            var clock = App.ServiceProvider.GetService<ClockService>() ?? new ClockService();
            clock.OnTick += ParseTick;
            await clock.InitializeAsync();

            CurrentClockTime = clock.ClockTimeData;
        }

        /// <summary>
        /// Retrieves the current clock time.
        /// </summary>
        /// <remarks>The returned value represents the current time based on the system clock or a custom
        /// clock source if <see cref="CurrentClockTime"/> is overridden. This method is intended for internal
        /// use.</remarks>
        /// <returns>The current date and time as a <see cref="DateTime"/> object.</returns>
        private DateTime GetCurrentClockTime() => CurrentClockTime.CurrentTime;

        /// <summary>
        /// Registra la marca de tiempo actual del cliente en el servidor.
        /// </summary>
        private async Task TakeMyTime()
        {
            try {
                ScantRequest scantreq = new() {
                    Question = (
                        GlobalVars.clockSettings?.clock_uuid ?? Guid.Empty.ToString() + "|" +
                        GlobalVars.clockSettings?.clock_office.ToString() + "|" +
                        GetCurrentClockTime().ToString("yyyy/MM/ddTHH:mm:ss")
                    )
                };

                await CommonProcs.SyncWatchesAsync(scantreq);
            } catch(Exception ex) {
                log.Warn("No se pudo registrar la hora del reloj en el servidor: " + ex.Message);
                return;
            }
        }

        /// <summary>
        /// Recupera las huellas dactilares de los empleados asignados a la oficina actual.
        /// </summary>
        private async Task<bool> GetFMDs()
        {
            DataTable emp_dt;

            int el_idx = 0;
            las_fmds = null;
            fmd_collection = null;
            las_fmds = [];
            fmd_collection = [];

            if (!GlobalVars.BeOffline)
            {
                emp_dt = await CommonProcs.GetOfficeFMDsAsync(new ScantRequest { Question = GlobalVars.clockSettings?.clock_office.ToString() });

                if (emp_dt == null)
                {
                    emp_dt = VoidFMDs;
                } else {
                    await GlobalVars.AppCache.SaveEmployeesAsync(emp_dt);
                }
            } else {
                emp_dt = GlobalVars.AppCache.RetrieveEmployees();
            }

            foreach (DataRow dr in emp_dt.Rows)
            {
                las_fmds.Add(new Fmd(SimpleAES.ToHexBytes(dr["FingerFMD"].ToString()!), GlobalVars.FMDFormat, GlobalVars.FMDVersion));

                var item = new FMDItem {
                    idx = el_idx,
                    offid = int.Parse(dr["OffID"].ToString() ?? "0"),
                    empid = int.Parse(dr["EmpID"].ToString() ?? "0"),
                    fingid = int.Parse(dr["FingerID"].ToString() ?? "0"),
                    empnum = dr["EmpNum"].ToString(),
                    empnom = dr["EmpName"].ToString(),
                    emppass = dr["EmpPass"].ToString(),
                    fmd = SimpleAES.ToHexBytes(dr["FingerFMD"].ToString()!)
                };

                fmd_collection.Add(item);
                FingerPrints.Add(item);

                el_idx++;
            }

            if (las_fmds.Count <= 0) las_fmds.Add(new Fmd(new byte[124], GlobalVars.FMDFormat, GlobalVars.FMDVersion));

            if ((emp_dt == null || emp_dt.Rows.Count <= 0) && GlobalVars.StartingUp)
            {
                SyncError = "No se han encontrado colaboradores asignados a la oficina actualmente configurada.";

                return false;
            }
            else
            {
                return true;
            }
        }

        private void SetOffice()
        {
            Office = (GlobalVars.this_office?.Offname + ".");
        }

        private void SetLogo()
        {
            var logo = GlobalVars.mainSettings?.Logo ?? "";

            LogoImage = !string.IsNullOrEmpty(logo) ? ImageHelper.LoadFromResource(logo) : ImageHelper.LoadFromAvares("/Assets/DefaultLogo.png");
        }

        /// <summary>
        /// Inicializa el lector de huella dactilar y lo prepara para la captura.
        /// </summary>
        private void StartReader()
        {
            //if (!GlobalVars.NoFPReader) return;
            try {
                UrUClass.LoadCurrentReader();

                if (!UrUClass.OpenReader()) {
                    KillMe("No se pudo inicializar el Lector de Huellas.");
                }

                if (!UrUClass.StartCaptureAsync(OnCaptured))
                {
                    KillMe("El manejador de evento del Lector de Huella no se puedo asociar.");
                }
            } catch(Exception ex) {
                Dispatcher.UIThread.InvokeAsync(async () => {
                    log.Warn("Error general del Lector de Huellas ==> " + ex.Message);
                    await Show(null, "Lector no encontrado", "No se ha encontrado ningún lector de huella dactilar o no se ha podido tener acceso al mismo.\n\nPruebe una de las siguientes opciones:\n\n1. Rectifique que el lector se encuentra debidamente conectado al equipo; deberá ver una luz azul en el lector que así lo indica.\n2. Asegúrese que los controladores necesarios han sido correctamente instalados.\n3. Conecte y desconecte el lector o conéctelo a un puerto USB diferente.\n4. Reinicie el equipo.\n\nSi el problema persiste, póngase en contacto con el administrador del sistema.\n\nLa aplicación terminará ahora.", MessageBoxButtons.Ok);
                    KillMe("Error general del Lector de Huellas ==> " + ex.Message);
                });
            }
        }
        #endregion

        #region Acciones del formulario
        /// <summary>
        /// Termina la aplicación.
        /// </summary>
        private void KillMe(string reason = "")
        {
            forceexit = true;
            GlobalVars.ForceExit = forceexit;
            log.Info("Se ha forzado el cierre de la aplicación." + (reason != "" ? (" " + reason): ""));
            Dispatcher.UIThread.InvokeAsync(async () => {
                await new MainWindow().LogOut(forceexit);
            });
        }

        /// <summary>
        /// Evalúa la operación a ejecutar cada vez que se actualiza el reloj. Muestra la hora actual y la fecha larga en la interfaz.
        /// </summary>
        private void ParseTick(ClockTimeData rt)
        {
            CurrentClockTime = rt;
            CurrentTime = rt.TimeString!;
            CurrentLongDate = LongDateFormat(rt.CurrentTime);

            // Verificar la sincronización programada por cada tick
            if (CheckSyncDTime())
            {
                log.Info("Sincronización programada iniciada.");
                ScheduleTriggered = true;
                Dispatcher.UIThread.InvokeAsync(async () => {
                    await SyncWithLoader();
                    await SendEmployeesWithNoCheckInOut();
                });
            }
            IsWebSocketConnected = _realtime?.IsConnected ?? false;
        }

        /// <summary>
        /// Enviar al correo configurado el listado de empleados que no han registrado entrada o salida en la oficina actual.
        /// </summary>
        /// <returns></returns>
        private static async Task SendEmployeesWithNoCheckInOut()
        {
            var offId = GlobalVars.this_office?.Offid ?? 0;
            var offName = GlobalVars.this_office?.Offname ?? "";

            var dt = await DBMethods.GetEmployeesWithNoCheckInOut(offId);
            var duplicatedPunches = await DBMethods.GetDuplicatedPunches(offId);

            var body = EmailSenderHandler.BuildMessage(dt, duplicatedPunches);

            if (dt.Rows.Count > 0 && dt.Columns.Contains("ERROR") && dt.Rows[0]["ERROR"].ToString() != "None") {
                return;
            }

            if(dt.Rows.Count <= 0) {
                return;
            }

            log.Info("Enviando correo de empleados sin checadas de entrada/salida...");
            await Task.Run(async () => {
                await EmailSenderHandler.SendEmailAsync((!string.IsNullOrEmpty(offName) ? offName + " - ": "") + "Control de Asistencia", body);
            });
        }

        /// <summary>
        /// Carga y reproduce el sonido indicado, delegando la operación al UIService.
        /// </summary>
        public static async Task PlayBeep(int beepType = 0)
        {
            var ui = App.ServiceProvider.GetService<UIService>() ?? new UIService();
            await ui.PlayBeep(beepType);
        }

        /// <summary>
        /// Detiene la reproducción actual, delegando la operación al UIService.
        /// </summary>
        private static void StopSound()
        {
            var ui = App.ServiceProvider.GetService<UIService>() ?? new UIService();
            ui.StopSound();
        }
        #endregion

        #region Manejadores de eventos
        /// <summary>
        /// Procesa la huella capturada por el lector.
        /// </summary>
        /// <param name="captureResult">Datos capturados por el lector.</param>
        public void OnCaptured(CaptureResult captureResult)
        {
            IDThreshold = CommonProcs.ParamInt(7) * 1 / CommonProcs.ParamInt(8);

            // Check capture quality and throw an error if bad.
            if (!UrUClass.CheckCaptureResult(captureResult)) return;

            DataResult<Fmd> preIdentify = FeatureExtraction.CreateFmdFromFid(captureResult.Data, Constants.Formats.Fmd.ISO);
            IdentifyResult identified = Comparison.Identify(preIdentify.Data, 0, las_fmds, IDThreshold, 1);

            if (identified.ResultCode == Constants.ResultCode.DP_SUCCESS) {
                FoundIndex = (identified.Indexes.Length > 0) ? identified.Indexes[0][0] : -1;
                Dispatcher.UIThread.InvokeAsync(PunchRegister);
                //UrUClass.ControlControls(4, btnParseID);
            } else if (identified.ResultCode == Constants.ResultCode.DP_DEVICE_BUSY) {
                Dispatcher.UIThread.InvokeAsync(async () => {
                    await ShowMessage("El lector no responde", "El lector de huella dactilar está ocupado y no responde en estos momentos. Por favor, espere unos segundos e inténtelo de nuevo");
                });
            } else {
                forceexit = true;
                Dispatcher.UIThread.InvokeAsync(async() => {
                    await ShowMessage("Fallo del lector", "Ha ocurrido un fallo con el lector de huella dactilar o ha dejado de ser reconocido por el sistema.\n\nLa aplicación no puede continuar y se cerrará ahora.", -1, -1, SizeToContent.Height);
                    KillMe("Fallo del Lector dactilar o ha dejado de ser reconocido por el sistema.");
                });
                //UrUClass.ControlControls(3, this);
            }
        }

        /// <summary>
        /// Detiene el lector de huella y libera los recursos tras el cierre del formulario.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void CloseReader()
        {
            UrUClass.CancelCaptureAndCloseReader(OnCaptured);
        }
        #endregion

        #region Objetos dinómicos
        private CancellationTokenSource _cancellationTokenSource = new();
        
        /// <summary>
        /// Actualiza las etiquetas(Leyendas) al procesar la información de eventos.
        /// </summary>
        /// <param name="la_action">La acción a la que se hace referencia.</param>
        /// <param name="emp_num">Número del colaborador.</param>
        /// <param name="emp_nom">Nombre del colaborador.</param>
        /// <param name="la_punch">Objeto que encapsula la información del registro de asistencia.</param>
        private async Task UpdateInfoLabels(int la_action, string? emp_num = null, string? emp_nom = null, PunchLine? la_punch = null)
        {
            _cancellationTokenSource.Cancel();
            _cancellationTokenSource = new CancellationTokenSource();

            // percepción de respuesta inmediata y evitar que el render se posponga.
            if (la_action != 4)
            {
                try {
                    await Task.Delay(200, _cancellationTokenSource.Token);
                } catch (TaskCanceledException) {
                    return;
                }
            }

            var ui = App.ServiceProvider.GetService<UIService>() ?? new UIService();
            var (name, eventText) = ui.BuildInfoLabels(la_action, emp_num, emp_nom, la_punch);
            EmployeeName = name;
            EmployeeEvent = eventText;

            // Cuando mostramos "Procesando...", pedimos al dispatcher que procese el ciclo de
            // render de inmediato para que el usuario vea el mensaje antes de operaciones pesadas.
            if (la_action == 4)
            {
                await Dispatcher.UIThread.InvokeAsync(() => { }, DispatcherPriority.Render);
            }
        }
        #endregion
    }
}
